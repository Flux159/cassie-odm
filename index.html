<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>cassie-odm by Flux159</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">cassie-odm</h1>
      <h2 class="project-tagline">Lightweight Nodejs Object Model Layer for Apache Cassandra</h2>
      <a href="https://github.com/Flux159/cassie-odm" class="btn">View on GitHub</a>
      <a href="https://github.com/Flux159/cassie-odm/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Flux159/cassie-odm/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="cassie" class="anchor" href="#cassie" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cassie</h1>

<p>Cassie is a lightweight model layer and CQL generator written in javascript that uses the <a href="https://github.com/jorgebay/node-cassandra-cql">node-cassandra-cql</a> project and attempts to mimic most of mongoose's API to allow for relatively easy switching between MongoDB and Cassandra. Cassie is a small module written completely in javascript and has a small dependency tree. Cassie supports data modeling, syncing tables, standard CRUD operations, Validations, Hooks, Plugins, Lightweight Transactions, Time to Live queries, batching, streaming queries, timing, and debugging queries (with 'pretty debugging' for supported terminals). Note that Cassie-ODM is not currently a full 1:1 mapping to mongoose's API.</p>

<p>Cassie is currently in beta (as of v0.1.0). Use at your own risk in production environments.</p>

<h2>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installing</h2>

<p>If you have nodejs installed, just run the following in your project's directory:</p>

<pre><code>    npm install cassie-odm
</code></pre>

<p>Also note that to use any of the examples below, it is assumed that you have Cassandra downloaded and running (default port of 9042). See the <a href="http://cassandra.apache.org/download/">Apache Cassandra Download</a> page for how to install Cassandra. Alternatively, get Cassandra from the <a href="http://planetcassandra.org/cassandra/">Datastax Community Distribution</a>. For OSX, you can install Cassandra from homebrew (see <a href="http://christopher-batey.blogspot.com/2013/05/installing-cassandra-on-mac-os-x.html">this</a>). For debian based systems (Ubuntu), you can install from apt-get.</p>

<h2>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h2>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> cassie <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>cassie-odm<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> config <span class="pl-k">=</span> {keyspace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>CassieTest<span class="pl-pds">"</span></span>, hosts<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:9042<span class="pl-pds">"</span></span>]};
    cassie.connect(config);

    <span class="pl-k">var</span> CatSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">cassie.Schema</span>({name<span class="pl-k">:</span> <span class="pl-c1">String</span>});
    <span class="pl-k">var</span> Cat <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Cat<span class="pl-pds">'</span></span>, CatSchema);

    cassie.syncTables(config, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {

        <span class="pl-k">var</span> kitty <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Cat</span>({ name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Eevee<span class="pl-pds">'</span></span>});
        kitty.save(<span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
            <span class="pl-k">if</span>(err) <span class="pl-k">return</span> <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>meow<span class="pl-pds">"</span></span>);
            cassie.<span class="pl-c1">close</span>();
        });

    });

</pre></div>

<h2>
<a id="modeling" class="anchor" href="#modeling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modeling</h2>

<p>Modeling is the process of defining your Schemas. Although Cassandra is a NoSQL database, it is required to make a column family with a primary key. Cassie makes this process easier by helping you organize your code by defining Schemas in a single location (for easy reference). If you do not specify a primary key, Cassie will automatically generate an 'id' key for you. Modeling also allows you to perform validations and apply pre and post hooks to your models. Finally, Cassie will actually sync your tables forward to make rapid development easier ( tables and fields that don't exist in Cassandra will be created. Cassie does not delete tables or fields as this could lead to data loss. Cassie can warn you if there are unused fields though, see the "Sync" section for more information).</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> cassie <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>cassie-odm<span class="pl-pds">'</span></span>),
        Schema <span class="pl-k">=</span> cassie.Schema; <span class="pl-c">//Require cassie module</span>

    <span class="pl-k">var</span> config <span class="pl-k">=</span> {keyspace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>CassieTest<span class="pl-pds">"</span></span>, hosts<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:9042<span class="pl-pds">"</span></span>]};
    cassie.connect(config); <span class="pl-c">//Connect to local cassandra server</span>

    <span class="pl-c">//User Schema</span>
    <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        username<span class="pl-k">:</span> <span class="pl-c1">String</span>,
        email<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        hashed_password<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        blogs<span class="pl-k">:</span> [cassie.types.uuid]});

    <span class="pl-c">//Adds a validator for username</span>
    UserSchema.validate(<span class="pl-s"><span class="pl-pds">'</span>username<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">user</span>) {
        <span class="pl-k">return</span> (user.username <span class="pl-k">!==</span> <span class="pl-c1">null</span>);
    }, <span class="pl-s"><span class="pl-pds">"</span>Username cannot be empty.<span class="pl-pds">"</span></span>);

    <span class="pl-c">//Add a post-save hook</span>
    UserSchema.post(<span class="pl-s"><span class="pl-pds">'</span>save<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>A new user signed up!<span class="pl-pds">"</span></span>);
    });

    <span class="pl-c">//Blog Schema</span>
    <span class="pl-k">var</span> BlogSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({title<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>}, content<span class="pl-k">:</span> <span class="pl-c1">String</span>, author<span class="pl-k">:</span> <span class="pl-c1">String</span>});

    <span class="pl-c">//Registers the schemas with cassie</span>
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
    <span class="pl-k">var</span> Blog <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Blog<span class="pl-pds">'</span></span>, BlogSchema);

    <span class="pl-c">//Sync the schemas with Cassandra to ensure that they exist and contain the appropriate fields (see additional notes on the limitations of syncing)</span>
    <span class="pl-k">var</span> syncOptions <span class="pl-k">=</span> {debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, prettyDebug<span class="pl-k">:</span> <span class="pl-c1">true</span>, warning<span class="pl-k">:</span> <span class="pl-c1">true</span>};
    cassie.syncTables(config, syncOptions, <span class="pl-k">function</span> (<span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);

        <span class="pl-c">//Creates a new user</span>
        <span class="pl-k">var</span> newUser <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>({username<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>ManBearPig<span class="pl-pds">'</span></span>, email<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>AlGore@gmail.com<span class="pl-pds">'</span></span>, hashed_password<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Never-do-this-use-crypto-module<span class="pl-pds">'</span></span>});

        <span class="pl-c">//Asynchronous function that returns to provided callback</span>
        newUser.save({debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, prettyDebug<span class="pl-k">:</span> <span class="pl-c1">true</span>}, <span class="pl-k">function</span> (<span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {
            <span class="pl-k">if</span> (err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);

            <span class="pl-c">//Creates a new blog</span>
            <span class="pl-k">var</span> newBlog <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Blog</span>({title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Global warming and Manbearpig<span class="pl-pds">'</span></span>, content<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Half-man, half-bear, half-pig...<span class="pl-pds">'</span></span>, author<span class="pl-k">:</span> newUser.username});

            <span class="pl-c">//.save() without a callback returns a Query object. Here we batch together multiple queries to execute them together</span>
            <span class="pl-k">var</span> firstQuery <span class="pl-k">=</span> newBlog.save();

            <span class="pl-c">//Note that for types other than arrays and maps, cassie tracks changes for saving, however, since blogs is an array, we need to mark it as modified</span>
            <span class="pl-c">//Also note that after running .save(), newBlog has a generated field called 'id'. This only occurs if cassie created the primary key for us (see "Primary Keys" for more info).</span>
            newUser.blogs.<span class="pl-c1">push</span>(newBlog.<span class="pl-c1">id</span>);
            newUser.markModified(<span class="pl-s"><span class="pl-pds">'</span>blogs<span class="pl-pds">'</span></span>);

            <span class="pl-c">//Get second query to batch</span>
            <span class="pl-k">var</span> secondQuery <span class="pl-k">=</span> newUser.save();

            <span class="pl-c">//Run batch cql commands</span>
            cassie.batch([firstQuery, secondQuery], {consistency<span class="pl-k">:</span> cassie.consistencies.quorum, debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, prettyDebug<span class="pl-k">:</span> <span class="pl-c1">true</span>}, <span class="pl-k">function</span> (<span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {
                <span class="pl-k">if</span> (err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);

                <span class="pl-c">//Close the connection since we're done</span>
                cassie.<span class="pl-c1">close</span>();
            });
        });

    });

</pre></div>

<p>The above example shows a lot of code, but is relatively simple to understand (particularly if you've used Mongoose). First, we connect to the Cassandra server. Then, we create some schemas with cassie (along with a validator for username and a post-save hook on users). After we register the Schemas with cassie, we sync the tables to make sure that Cassandra knows that they exist (see "Sync" for more information on this and the limitations of syncing). Also note that we haven't provided a primary key in any of our schemas. In general, its good practice to explicitly define a primary key in Cassandra (and Cassandra requires it actually). Cassie takes care of this requirement by generating a field called 'id' if we don't specify a primary key. After we call the sync tables function, we can now create users and blogs in our database. First, we create a new user and save it. Then we create a new blog and store the query to be called with some other updates. Once we've done our updates locally, we gather the queries and send them in a batch to our Cassandra server using the cassie.batch command to create our blog post and update our user. Finally, we close the connection when we're done.</p>

<p>NOTE: All fields should be lowercase. This is due to Cassandra's columns being lowercase (and currently Cassie doesn't automatically covert these for you in javascript).</p>

<p>Some things to note about the above example:
    First, all fields inside of models must be lowercase. This is because when creating fields in Cassandra through CQL, fields are stored without any uppercase letters. Second, never store a password in plain text, ideally, you would use the crypto module to generate a hash of the user's password and store that in your database. Finally, this data model is not very efficient for a number of reasons that would make more sense if you read through the "Data Modeling Notes" and Cassandra's documentation / architecture (not posting here for brevity).</p>

<h2>
<a id="queries" class="anchor" href="#queries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Queries</h2>

<p>Construct and run CQL queries by passing arguments or chaining methods. See the following sections for basic CRUD operations.</p>

<h2>
<a id="crud-create-read-update-delete-operations" class="anchor" href="#crud-create-read-update-delete-operations" aria-hidden="true"><span class="octicon octicon-link"></span></a>CRUD (Create, Read, Update, Delete) Operations</h2>

<p>Create, Read, Update, Delete operations on Models.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Schema used for CRUD examples:</span>

    <span class="pl-k">var</span> FishSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        fish_id<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>, primary<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        name<span class="pl-k">:</span> <span class="pl-c1">String</span>
    });

    cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>, FishSchema);
</pre></div>

<p>Create Example (INSERT):</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Create Example (assuming schemas have been defined and sync'ed - see sync for more information)</span>
    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);

    <span class="pl-k">var</span> fishee <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Fish</span>({fish_id<span class="pl-k">:</span> <span class="pl-c1">2001</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>eevee<span class="pl-pds">'</span></span>});
    fishee.save(<span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-c">//Handle errors, etc.</span>
    });
</pre></div>

<p>Read Example (SELECT):</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Read Example (assuming schemas have been defined &amp; sync'ed - see sync for more information)</span>
    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);

    Fish.<span class="pl-c1">find</span>({fish_id<span class="pl-k">:</span> {$in<span class="pl-k">:</span> [<span class="pl-c1">2000</span>, <span class="pl-c1">2001</span>, <span class="pl-c1">2002</span>, <span class="pl-c1">2003</span>, <span class="pl-c1">2004</span>]}}).<span class="pl-c1">exec</span>(<span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fishes</span>) {
                <span class="pl-c">//Note: fishes is an array</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(fishes.<span class="pl-c1">toString</span>());
        <span class="pl-k">var</span> firstFish <span class="pl-k">=</span> fishes[<span class="pl-c1">0</span>]; <span class="pl-c">//...</span>
    });

</pre></div>

<p>Read Example 2 (SELECT LIMIT 1 - findOne):</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);

    Fish.findOne({fish_id<span class="pl-k">:</span> <span class="pl-c1">2000</span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fish</span>) {
            <span class="pl-c">//Note: fish is a single object</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(fish.<span class="pl-c1">toString</span>());
    });
</pre></div>

<p>Update Example (UPDATE):
Note: Cassie internally stores a flag to know when you've modified fields - for arrays and maps, you must specified that a field has been modified using the Model.markModified('fieldName'); method though (see 'Modeling' for an example)</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Update Example (assuming schemas have been defined &amp; sync'ed - see sync for more information)</span>

    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);

    <span class="pl-k">var</span> fishee2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Fish</span>({fish_id<span class="pl-k">:</span> <span class="pl-c1">2002</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>eevee<span class="pl-pds">'</span></span>});
    fishee2.save(<span class="pl-k">function</span>(<span class="pl-smi">err</span>) {

        <span class="pl-c">//Renaming the fish</span>
        fishee2.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>bambie<span class="pl-pds">'</span></span>;

        fishee2.save(<span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
            <span class="pl-c">//fishee2 has now been renamed (Cassie internally stores a flag to know when you've modified fields - for arrays and maps, you must specified that a field has been modified using the fishee2.markModified('fieldName'); method though (see 'Modeling' for an example).</span>
        });
    });

    <span class="pl-c">//Alternatively, you can also send update queries if you know some information about the model</span>

    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> fish_id3 <span class="pl-k">=</span> <span class="pl-c1">2003</span>; <span class="pl-c">//Assumes fish_id is a number. If uuid, would need to pass uuid as a string</span>

    Fish.update({fish_id<span class="pl-k">:</span> fish_id3}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bambie<span class="pl-pds">'</span></span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-k">if</span>(err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
        <span class="pl-c">//Fish with id 2000 has had its name updated</span>
        <span class="pl-c">//If no fish with id exists, returns error</span>
    });

    <span class="pl-c">//Fish.update can also take multiple ids in the same way as find: {id: {$in: [1234,1235]} or {id: [1234,1235]}</span>
</pre></div>

<p>Delete Example (DELETE):</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Delete Example (assuming schemas have been defined &amp; sync'ed - see sync for more information)</span>

    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);

    <span class="pl-k">var</span> fishee4 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Fish</span>({fish_id<span class="pl-k">:</span> <span class="pl-c1">2004</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>goldee<span class="pl-pds">'</span></span>});
    fishee4.save(<span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-k">if</span>(err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);

        fishee4.<span class="pl-c1">remove</span>(<span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
            <span class="pl-k">if</span>(err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
            <span class="pl-c">//Fishee has been removed.</span>
        });
    });

    <span class="pl-c">//Alternatively, you can also send delete queries if you know some information about the model (that Cassandra indexes by)</span>

    <span class="pl-k">var</span> Fish <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Fish<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> fish_id5 <span class="pl-k">=</span> <span class="pl-c1">2005</span>; <span class="pl-c">//Assumes fish_id is a number. If uuid, would need to pass uuid as a string</span>

    Fish.<span class="pl-c1">remove</span>({fish_id<span class="pl-k">:</span> fish_id5}, <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-k">if</span>(err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
        <span class="pl-c">//Fish with id 2001 has had its name deleted</span>
    });

    <span class="pl-c">//To delete entire row, ignore second argument. Ex:</span>
    <span class="pl-c">//Fish.remove({id: fish_id5}, function(err) {</span>
    <span class="pl-c">//Your callback code</span>
    <span class="pl-c">//});</span>

    <span class="pl-c">//Fish.remove can also take multiple ids in the same way as find: {id: {$in: [1234,1235]} or {id: [1234,1235]}</span>
</pre></div>

<h2>
<a id="types" class="anchor" href="#types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Types</h2>

<p>Cassie supports the following types. Note that arrays and Maps must have defined types.</p>

<p>String
Number (can specify Int by using cassie.types.Int, Double by cassie.types.Double, or Long by cassie.types.Long) - default is Int if you use Number
Date (a timestamp)
ObjectId (specified by cassie.types.ObjectId or cassie.types.uuid) - this is a uuid v4
Buffer (Cassandra stores as blobs)
Arrays (must specify internal type, like: [String])
Maps (must specify internal types, like {String: String} - arbitrary maps are not supported, use Buffers (Blobs) instead)</p>

<h2>
<a id="sync" class="anchor" href="#sync" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sync</h2>

<p>Syncing is the process of creating keyspaces (similar to a database in traditional RDBMs) and column families (similar to tables) from your schemas. Cassie handles the process of syncing via its syncTables function. Sync tables will create a keyspace if it doesn't exist, create column families if they don't exist, and alter column families if you've added fields to your schemas. Syncing also creates a primary key with the name of 'id' if you don't specify a different primary key. This allows you to rapidly iterate on modifying your schemas and keep your tables in sync. </p>

<p>However, syncing has some limitations in its current form. </p>

<p>Syncing cannot alter column names, so if you decide to change your column name, you would have to use cqlsh (see CQL documentation on ALTER TABLE with the RENAME clause <a href="http://www.datastax.com/documentation/cql/3.0/cql/cql_reference/alter_table_r.html">here</a>. This is because cassie doesn't know what you previously defined a column as (and it has no way of knowing that information).</p>

<p>Cassie cannot change the types of already defined columns. This is currently a limitation of Cassie's sync function and may be added later (see roadmap). </p>

<p>Cassie also cannot change the primary key for any table after it has been created (ie you must define your schemas according to query patterns for Cassandra to be effective, see "Data Modeling Notes"). This is a limitation of Cassandra.</p>

<p>Finally, Cassie does not delete columns or tables from your database if they aren't defined. You can pass a "warning: true" option to sync tables to tell you which columns are missing from your schemas, but Cassie will not delete the columns for you (to prevent unintended data loss). This is what "syncing forward" implies.</p>

<p>NOTE: Make sure to read about "Keyspace Replication Strategies and Production Notes" if you intend on using Cassandra in Production. It is required to understand replication strategies for production, particularly for automated deployment setups.</p>

<p>NOTE: Currently Cassie generates a table name by using a lowercase pluralized version of the Model name you specify (ie 'User' becomes 'users').</p>

<p>Here is an example of using sync tables to sync two tables to the database with debugging and warning flags enabled:</p>

<div class="highlight highlight-javascript"><pre>
        <span class="pl-k">var</span> cassie <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>../../lib/cassie<span class="pl-pds">'</span></span>),
            Schema <span class="pl-k">=</span> cassie.Schema; <span class="pl-c">//Require cassie module</span>

        <span class="pl-k">var</span> config <span class="pl-k">=</span> {keyspace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>CassieTest<span class="pl-pds">"</span></span>, hosts<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:9042<span class="pl-pds">"</span></span>]};
        cassie.connect(config); <span class="pl-c">//Connect to local cassandra server</span>

        <span class="pl-c">//User Schema</span>
        <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
            username<span class="pl-k">:</span> <span class="pl-c1">String</span>,
            email<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>},
            hashed_password<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>},
            blogs<span class="pl-k">:</span> [cassie.types.uuid]});

        <span class="pl-c">//Blog Schema</span>
        <span class="pl-k">var</span> BlogSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({title<span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>}, content<span class="pl-k">:</span> <span class="pl-c1">String</span>, author<span class="pl-k">:</span> <span class="pl-c1">String</span>});

        <span class="pl-c">//Registers the schemas with cassie</span>
        <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
        <span class="pl-k">var</span> Blog <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Blog<span class="pl-pds">'</span></span>, BlogSchema);

        <span class="pl-k">var</span> syncOptions <span class="pl-k">=</span> {debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, prettyDebug<span class="pl-k">:</span> <span class="pl-c1">true</span>, warning<span class="pl-k">:</span> <span class="pl-c1">true</span>};
        cassie.syncTables(config, syncOptions, <span class="pl-k">function</span> (<span class="pl-smi">err</span>) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
        });
</pre></div>

<p>When writing an application, the general idea is that you preload all your schemas into cassie, then sync your models once before running your other code (ie before starting an express application or web server). This will give you access to all your models whenever you need them by using the cassie.model('ModelName') function. This is similar to how Mongoose handles preloading schemas.</p>

<p>A final thing to note is that you can specify Keyspace replication strategy's in your Cassie config (if you let Cassie create your keyspaces for you - you can do this yourself through cqlsh, but Cassie can automate the process as well). See "Keyspace Replication Strategy and Production Notes" for more information.</p>

<h2>
<a id="table-creation-options-when-syncing" class="anchor" href="#table-creation-options-when-syncing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Table Creation Options when syncing</h2>

<p>"See Advanced Table Creation Options"</p>

<h2>
<a id="primary-keys" class="anchor" href="#primary-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary Keys</h2>

<p>Cassandra requires a primary key for all column families. This means that you would need to define a primary key whenever creating a table. Cassie relaxes that restriction slightly by allowing you to define Schemas without primary keys. However, what Cassie does internally is create an 'id' field on your Schema and adds a pre-save hook to generate an id for all new models (see "Hooks" for how you can do the same with your own fields). Cassie then marks this 'id' field as your primary key. This is important to note because primary keys cannot be modified using an ALTER TABLE command. In Cassandra, once your primary key has been set for a table, you're not allowed to modify it. If you want sophisticated primary keys (like composite primary keys), you need to design your Data Model appropriately from the beginning and make sure that you define it correctly in your Schema.</p>

<p>See "Data Modeling" notes for more information on designing appropriate models for common use cases. Take particular note of how composite primary keys can be used for quick advanced queries.</p>

<p>The examples below show how a primary key can be explicitly defined on a field, how a composite primary key can be defined, and how to allow Cassie to generate a primary key for you:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Explicitly defining a primary key</span>
    <span class="pl-k">var</span> DogSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        <span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>, primary<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>,
        <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>
    });

    <span class="pl-c">//Explicitly defining a composite primary key</span>
    <span class="pl-k">var</span> DogeSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        <span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>},
        <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>,
        <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>
    }, {primary<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span>]});

    <span class="pl-c">//Explicitly defining a composite primary key and partition key (row key is based on dog_id and fname)</span>
    <span class="pl-k">var</span> DawgSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        <span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>},
        <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>,
        <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>
    }, {primary<span class="pl-k">:</span> [[<span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span>], <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span>]});

    <span class="pl-c">//Cassie defines 'id' field for you - Note that in this case 'dog_id' is NOT the primary key, 'id' is (and 'id' is a uuid v4 type)</span>
    <span class="pl-c">//Cassie will also add a presave function that adds the 'id' field for you before you save a new model.</span>
    <span class="pl-k">var</span> DagSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        <span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>, <span class="pl-k">default</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>uuid<span class="pl-pds">'</span></span>},
        <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>,
        <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>
    });
</pre></div>

<h2>
<a id="secondary-indexing" class="anchor" href="#secondary-indexing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secondary Indexing</h2>

<p>Cassie supports secondary indexes on fields with the following option {index: true}. See the example below:</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-c">//Explicitly defining a primary key and defining a secondary index</span>
    <span class="pl-k">var</span> DogSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        <span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>, primary<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, index<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>
    });

    <span class="pl-c">//Alternative way of defining a secondary index</span>
    DogSchema.<span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span>);</pre></div>

<h2>
<a id="validations" class="anchor" href="#validations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Validations</h2>

<p>Validations are a core part of Cassie's Object Data Model. Validations allow you to easily reject inserts and updates across all your models in javascript without ever hitting your database. Cassie comes with internal support for a "required" validation and also allows you to validate any field with a custom function.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Requiring that 'fname' is provided (is not null)</span>
    <span class="pl-k">var</span> DogSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        <span class="pl-s"><span class="pl-pds">'</span>dog_id<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">Number</span>, primary<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        <span class="pl-s"><span class="pl-pds">'</span>fname<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, required<span class="pl-k">:</span> <span class="pl-c1">true</span>},
        <span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">String</span>
    });

    <span class="pl-c">//Adding a custom validation to 'lname'</span>
    DogSchema.validate(<span class="pl-s"><span class="pl-pds">'</span>lname<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">model</span>, <span class="pl-smi">fieldKey</span>) {
        <span class="pl-k">return</span> (model[fieldKey] <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>doge<span class="pl-pds">'</span></span>);
    }, <span class="pl-s"><span class="pl-pds">"</span>Last name is required.<span class="pl-pds">"</span></span>);

    <span class="pl-c">//A validate function is passed the model and the fieldKey to validate. It returns true or false.</span>
    <span class="pl-c">//The validation function above requires that 'lname' is equal to 'doge' for all models</span>
</pre></div>

<h2>
<a id="hooks" class="anchor" href="#hooks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hooks</h2>

<p>Cassie supports pre-save and pre-remove hooks for its models. It also supports post-init, post-validate, post-save, and post-remove hooks. The example below shows all of these being used.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> TrickSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span><span class="pl-k">:</span> {type<span class="pl-k">:</span> <span class="pl-c1">String</span>, index<span class="pl-k">:</span> <span class="pl-c1">true</span>}});

    TrickSchema.post(<span class="pl-s"><span class="pl-pds">'</span>init<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Initialized Trick<span class="pl-pds">"</span></span>);
    });

    TrickSchema.post(<span class="pl-s"><span class="pl-pds">'</span>validate<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Validated Trick<span class="pl-pds">"</span></span>);
    });

    TrickSchema.pre(<span class="pl-s"><span class="pl-pds">'</span>save<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>About to save (insert or update) trick to database<span class="pl-pds">"</span></span>);
    });

    TrickSchema.post(<span class="pl-s"><span class="pl-pds">'</span>save<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>, <span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {
        <span class="pl-k">if</span>(<span class="pl-k">!</span>err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Saved Trick to database<span class="pl-pds">"</span></span>);
    });

    TrickSchema.pre(<span class="pl-s"><span class="pl-pds">'</span>remove<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>About to remove trick (or trick fields) from database<span class="pl-pds">"</span></span>);
    });

    TrickSchema.post(<span class="pl-s"><span class="pl-pds">'</span>remove<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">model</span>, <span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {
        <span class="pl-k">if</span>(<span class="pl-k">!</span>err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Removed trick (or trick fields) from database<span class="pl-pds">"</span></span>);
    });

    cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Trick<span class="pl-pds">'</span></span>, TrickSchema);
</pre></div>

<p>Note that hooks are only called on Cassie object instances, not when performing Model.update or Model.remove (because those are direct database calls that don't generate any Cassie instances).</p>

<h2>
<a id="plugins" class="anchor" href="#plugins" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plugins</h2>

<p>Models support plugins. Plugins allow you to share schema properties between models and allow for pre-save hooks, validations, indexes, pretty much anything you can do with a Schema. Note that you can't modify primary keys or add primary keys in a plugin.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//updatedAtPlugin.js</span>
    <span class="pl-k">function</span> <span class="pl-en">updatedAtPlugin</span>(<span class="pl-smi">schema</span>, <span class="pl-smi">options</span>) {
        schema.<span class="pl-c1">add</span>({updated_at<span class="pl-k">:</span> <span class="pl-c1">Date</span>}); <span class="pl-c">//Adds a field to the model instance</span>

        schema.addQuery({<span class="pl-s"><span class="pl-pds">'</span><span class="pl-en">get</span><span class="pl-pds">'</span></span>: <span class="pl-k">function</span>(<span class="pl-smi">args</span>, <span class="pl-smi">callback</span>) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Inside Model get function<span class="pl-pds">"</span></span>);
            <span class="pl-k">var</span> results <span class="pl-k">=</span> args;
            callback(results);
        }});
        <span class="pl-c">//Adds a function to query by on Model class (like Model.find, Model.update, Model.remove)</span>
        <span class="pl-c">//This can be useful when making plugins that add query logic to a Model class</span>
        <span class="pl-c">//Example: Integrate an external data source / index in a plugin (like a search index), then add a method that will query that external data source</span>
        <span class="pl-c">//Combining pre/post save logic and queries can allow for expressive plugins</span>

        schema.pre(<span class="pl-s"><span class="pl-pds">'</span>save<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">model</span>) {
            model.updated_at <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Date</span>();
        });

        <span class="pl-k">if</span>(options <span class="pl-k">&amp;&amp;</span> options.<span class="pl-c1">index</span>) {
            schema.<span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">'</span>updated_at<span class="pl-pds">'</span></span>);
        }
    }

    <span class="pl-c">//user.js</span>
    <span class="pl-c">//var updatedAtPlugin = require('./updatedAtPlugin');</span>
    <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({name<span class="pl-k">:</span> <span class="pl-c1">String</span>});
    UserSchema.plugin(updatedAtPlugin, {index<span class="pl-k">:</span> <span class="pl-c1">true</span>});

    <span class="pl-c">//blog.js</span>
    <span class="pl-c">//var updatedAtPlugin = require('./updatedAtPlugin');</span>
    <span class="pl-k">var</span> BlogSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({title<span class="pl-k">:</span> <span class="pl-c1">String</span>});
    BlogSchema.plugin(updatedAtPlugin, {index<span class="pl-k">:</span> <span class="pl-c1">true</span>});

    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
    <span class="pl-k">var</span> Blog <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Blog<span class="pl-pds">'</span></span>, BlogSchema);

    <span class="pl-c">//Can now perform queries like:</span>
    User.get(<span class="pl-s"><span class="pl-pds">'</span>args<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">results</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(results);
    });
</pre></div>

<h2>
<a id="lightweight-transactions" class="anchor" href="#lightweight-transactions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lightweight Transactions</h2>

<p>Cassie supports lightweight transactions for saving new data via the {if_not_exists: Boolean} option.</p>

<p>For updating data, you can use the IF field = 'value' CQL command by passing {if: {field: value}} as an option to save.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>);

    <span class="pl-c">//Assumption is that user_id is primary key</span>
    <span class="pl-k">var</span> new_user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">2000</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>steve<span class="pl-pds">'</span></span>});

    new_user.save({if_not_exists<span class="pl-k">:</span> <span class="pl-c1">true</span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-c">//Handle errors, etc.</span>

        <span class="pl-c">//Same user using IF field = value</span>
        new_user.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bill<span class="pl-pds">"</span></span>;

        new_user.save({if<span class="pl-k">:</span> {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bob<span class="pl-pds">'</span></span>}, debug<span class="pl-k">:</span> <span class="pl-c1">true</span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {

            <span class="pl-c">//Handle errors, etc.</span>
            <span class="pl-c">//Note that this query will not update new_user because new_user's name is not 'bob'</span>

        });

    });

</pre></div>

<h2>
<a id="time-to-live-ttl" class="anchor" href="#time-to-live-ttl" aria-hidden="true"><span class="octicon octicon-link"></span></a>Time to Live (TTL)</h2>

<p>Cassie supports specifying a TTL when inserting data via the {ttl: Number} option, where Number is the time in seconds. Also see "Sessions".</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> Post <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>Post<span class="pl-pds">'</span></span>);

    <span class="pl-k">var</span> new_post <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Post</span>({title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>My time limited post<span class="pl-pds">'</span></span>});

    new_post.save({ttl<span class="pl-k">:</span> <span class="pl-c1">86400</span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-c">//Handle errors, etc.</span>
    });
</pre></div>

<h2>
<a id="limit--sorting" class="anchor" href="#limit--sorting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Limit &amp; Sorting</h2>

<p>Cassie can limit your queries based on options or by chaining queries. See the examples below:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>);

    User.<span class="pl-c1">find</span>({}, {limit<span class="pl-k">:</span> <span class="pl-c1">10</span>, sort<span class="pl-k">:</span> {name<span class="pl-k">:</span> <span class="pl-c1">1</span>}}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">users</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(users.<span class="pl-c1">toString</span>());
    });

    <span class="pl-c">//Same query as above using chaining</span>
    User.<span class="pl-c1">find</span>({}).limit(<span class="pl-c1">10</span>).<span class="pl-c1">sort</span>({name<span class="pl-k">:</span> <span class="pl-c1">1</span>}).<span class="pl-c1">exec</span>(<span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">users</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(users.<span class="pl-c1">toString</span>());
    });

</pre></div>

<h2>
<a id="batching" class="anchor" href="#batching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Batching</h2>

<p>Cassie can batch queries together to run at once. This is done by not specifying a callback to an insert or delete function and passing an array of queries to cassie.batch(). See the example below:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> new_user_1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">1000</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Bob<span class="pl-pds">'</span></span>});
    <span class="pl-k">var</span> new_user_2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">2000</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Steve<span class="pl-pds">'</span></span>});

    <span class="pl-k">var</span> query_1 <span class="pl-k">=</span> new_user_1.save();
    <span class="pl-k">var</span> query_2 <span class="pl-k">=</span> new_user_2.save();

    <span class="pl-k">var</span> batchOptions <span class="pl-k">=</span> {debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, prettyDebug<span class="pl-k">:</span> <span class="pl-c1">true</span>, timing<span class="pl-k">:</span> <span class="pl-c1">true</span>};
    cassie.batch([query_1, query_2], batchOptions, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-c">//Handle errors, etc.</span>
        <span class="pl-k">if</span>(err) <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
    });

</pre></div>

<h2>
<a id="execute-prepared" class="anchor" href="#execute-prepared" aria-hidden="true"><span class="octicon octicon-link"></span></a>Execute Prepared</h2>

<p>Cassie can execute prepared queries by passing in a "prepared" option when calling exec (either through a callback or through Query.exec() directly). See the examples below:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>);

    User.<span class="pl-c1">find</span>({user_id<span class="pl-k">:</span> {$in<span class="pl-k">:</span> [<span class="pl-c1">1000</span>, <span class="pl-c1">1001</span>, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>]}}, {prepared<span class="pl-k">:</span> <span class="pl-c1">true</span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">users</span>) {
        <span class="pl-c">//Handle errors, do stuff w/ results</span>
    });

    <span class="pl-c">//This is equivalent to the above</span>
    <span class="pl-k">var</span> query <span class="pl-k">=</span> User.<span class="pl-c1">find</span>({user_id<span class="pl-k">:</span> {$in<span class="pl-k">:</span> [<span class="pl-c1">1000</span>, <span class="pl-c1">1001</span>, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>]}});
    query.<span class="pl-c1">exec</span>({prepared<span class="pl-k">:</span> <span class="pl-c1">true</span>}, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">users</span>) {
        <span class="pl-c">//Handle errors, do stuff w/ results</span>
    });
</pre></div>

<h2>
<a id="streaming" class="anchor" href="#streaming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Streaming</h2>

<p>Cassie supports streaming results via a Query.stream(options, callback) method. This returns a readable stream (can view documentation for node-cassandra-cql streams as well). See the example below:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>);

    <span class="pl-k">var</span> query <span class="pl-k">=</span> User.<span class="pl-c1">find</span>({user_id<span class="pl-k">:</span> {$in<span class="pl-k">:</span> [<span class="pl-c1">1000</span>, <span class="pl-c1">1001</span>, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>]}});
    query.stream()
        .on(<span class="pl-s"><span class="pl-pds">'</span>readable<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>() {
            <span class="pl-k">var</span> row;
            <span class="pl-k">while</span>(row <span class="pl-k">=</span> <span class="pl-v">this</span>.read()) {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>(row);
            }
        })
        .on(<span class="pl-s"><span class="pl-pds">'</span>end<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>() {
            <span class="pl-c">//Stream ended</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Stream ended<span class="pl-pds">"</span></span>);
            cassie.<span class="pl-c1">close</span>();
        })
        .on(<span class="pl-s"><span class="pl-pds">'</span>error<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
            <span class="pl-c">//Stream error</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
        });
</pre></div>

<h2>
<a id="timing-debugging-and-logging" class="anchor" href="#timing-debugging-and-logging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Timing, Debugging, and Logging</h2>

<p>Cassie supports timing and debugging capabilities (including a prettyDebug mode which prints using colored text to a supported terminal and is far more human readable than standard debugging). These options are supported on almost all Cassie queries (timing is not supported on sync tables because it should really only be called once after preloading all your schemas). To use the options, simply pass the following object to a query as part of its options:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> options <span class="pl-k">=</span> {debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, timing<span class="pl-k">:</span> <span class="pl-c1">true</span>, prettyDebug<span class="pl-k">:</span> <span class="pl-c1">true</span>};

    <span class="pl-c">//Examples</span>

    <span class="pl-c">//User.find({}, options, callback);</span>

    <span class="pl-c">//var user = new User({name: 'Steve'});</span>
    <span class="pl-c">//user.save(options, callback);</span>

    <span class="pl-c">//var query = user.save();</span>
    <span class="pl-c">//query.exec(options, callback);</span>
</pre></div>

<p>Note that pretty debugging should not be used for logs as it uses escaped characters to print in color (google ASCII color codes). It is primarily useful for development purposes.</p>

<p>You can also pass a logger like <a href="https://github.com/flatiron/winston">winston</a> in by providing the winston object in the "logger" property.</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-k">var</span> winston <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>winston<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> options <span class="pl-k">=</span> {debug<span class="pl-k">:</span> <span class="pl-c1">true</span>, timing<span class="pl-k">:</span> <span class="pl-c1">true</span>, logger<span class="pl-k">:</span> winston};</pre></div>

<h2>
<a id="client-connections-and-raw-queries" class="anchor" href="#client-connections-and-raw-queries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client Connections and raw queries</h2>

<p>Client connections are handled by node-cassandra-cql. Cassie encapsulates a connection internally, but you can also use the node-cassandra-cql connection directly for CQL queries:</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-k">var</span> cassie <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>cassie-odm<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> connection <span class="pl-k">=</span> cassie.connect({keyspace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>mykeyspace<span class="pl-pds">"</span></span>, hosts<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:9042<span class="pl-pds">"</span></span>]});

    connection.execute(<span class="pl-s"><span class="pl-pds">"</span>SELECT * FROM cats<span class="pl-pds">"</span></span>, [], <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">results</span>) {
        <span class="pl-k">if</span>(err) <span class="pl-k">return</span> <span class="pl-en">console</span><span class="pl-c1">.log</span>(err);
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>meow<span class="pl-pds">"</span></span>);
    });
</pre></div>

<h2>
<a id="advanced-table-creation-options" class="anchor" href="#advanced-table-creation-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Advanced Table Creation Options</h2>

<p>There are a few queries that can be efficiently executed if you use on-disk sorting of columns when creating tables. Cassie allows you to specify options for creating tables when defining your schemas. See "Data Modeling Notes" for more information on efficient client queries. See <a href="http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/refClstrOrdr.html">Using Clustering Order</a> for Clustering Order option. Cassie only supports the clustering order option at the moment (adding all table properties is on the roadmap, you can modify them manually currently using CQL's ALTER TABLE command).</p>

<p>See <a href="http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/create_table_r.html">CQL Create Table documentation</a> and <a href="http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/tabProp.html">CQL Table Properties</a> for all the advanced options. </p>

<div class="highlight highlight-javascript"><pre>
<span class="pl-k">var</span> EventSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({
        event_type<span class="pl-k">:</span> <span class="pl-c1">String</span>,
        insertion_time<span class="pl-k">:</span> cassie.types.Timestamp,
        <span class="pl-c1">event</span><span class="pl-k">:</span> cassie.types.Blob
    },
    {
        primary<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>event_type<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>insertion_time<span class="pl-pds">'</span></span>],
        create_options<span class="pl-k">:</span> {
            clustering_order<span class="pl-k">:</span> {<span class="pl-s"><span class="pl-pds">'</span>insertion_time<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>}
        }
    });
</pre></div>

<h2>
<a id="keyspace-replication-strategy-and-production-notes" class="anchor" href="#keyspace-replication-strategy-and-production-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keyspace Replication Strategy and Production notes</h2>

<p>By default, cassie assumes that you are developing locally and creates keyspaces with a "Simple Replication Strategy" and a replication factor of 1. This is not ideal for a production setup. A production Cassandra cluster will generally have a minimum of 3 nodes, a "Network Topology Replication Strategy" and a replication factor of 3. What this means is that you have 3 instances of Cassandra running (generally on separate servers). This allows you to survive the loss of one of the servers without losing your data (and once a third node is added back, Cassandra will automatically populate the node with the data it needs). Since cassie can create keyspaces, it needs to know what strategy to use when creating the keyspace. It does this by checking for options in your connection configuration. Specifically, it checks for a field "replication" that contains an object with the replication options. See the example below for the default setting and for a standard "Network Topology with replication factor of 3" setting.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Standard setting (passed to cassie)</span>
    config {
        hosts<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>127.0.0.1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>127.0.0.2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>127.0.0.3<span class="pl-pds">'</span></span>],
        keyspace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>mykeyspace<span class="pl-pds">'</span></span>,
        replication<span class="pl-k">:</span> {
            strategy<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>SimpleStrategy<span class="pl-pds">'</span></span>, <span class="pl-c">//Default is 'SimpleStrategy', NOTE: Use 'NetworkTopologyStrategy' for production</span>
            replication_factor<span class="pl-k">:</span> <span class="pl-c1">1</span>, <span class="pl-c">//Default is 1 (only used with SimpleStrategy). Not used for 'NetworkTopologyStrategy'</span>
            strategy_options<span class="pl-k">:</span> { <span class="pl-c">//Strategy options is only used for NetworkTopologyStrategy, not for SimpleStrategy</span>
                <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">3</span>
                <span class="pl-c">// '10':3,</span>
                <span class="pl-c">// '20':3</span>
            }
    }

    <span class="pl-c">//Strategy options is only taken into account for NetworkTopologyStrategy - if not specified, then throws error if trying to sync. The key specified in strategy options is your database name (which varies based on what "Snitch" you set in your cassandra.yaml file. For a file property based snitch, you would define it to be your database name. The '0' here is specified if you use a RankInferringSnitch and your database is located at an internal IP of xxx.0.xxx.xxx (see Cassandra Documentation for more information).</span>

</pre></div>

<h2>
<a id="common-issues-using-cassandra" class="anchor" href="#common-issues-using-cassandra" aria-hidden="true"><span class="octicon octicon-link"></span></a>Common Issues using Cassandra</h2>

<p>You can't sort or use greater than or less than operators on a non-composite primary key column (see example below on what you can sort on). Partition keys can only be searched using equality or "IN". The way to get around this is to use composite primary keys with the appropriate columns. Because of this, you need to design your data models differently (full normalization is generally not a good idea, your data needs to be partially denormalized for good consistent performance - see Data modeling notes for more information).</p>

<p>According to some Datastax documentation, secondary indices are usually only good when you have fields that are common across many rows. A good example is when you have a list of people, each containing state and country information. You would put a secondary index on the state field and on the country field if you wanted to query "What users are located in this state" or "What users are located in this country". You can only use equality operators on secondary indices (see example below)</p>

<p>Unlike MySQL, PostgreSQL, or other Relational Databases, you can't do JOINs across tables in Cassandra. This also means that its not a good idea to fully normalize your data (see "Data Modeling Notes". </p>

<p>Unlike MongoDB (or recent versions of PostgreSQL with hstore/json data types), you can't put arbitrary JSON data into Cassandra (must define a schema - although you can always add columns later). Note that you can put maps and blobs/buffers into Cassandra, but its generally not a good idea to use Blobs over 10MB according to many data modeling best practices. Also note that you could store the json as a string and handle JSON stringifying during inserts and JSON parsing during retrieval. Cassie relaxes schema definitions significantly by auto syncing your tables and warning you when your schema may be missing columns that are defined in the database. However, do note that primary keys are defined at table CREATION time and cannot be altered.</p>

<p>Unlike MongoDB and Riak, Cassandra doesn't come with full text search built-in. You would need to use Apache Solr, Elastic Search, or any other full text search indexing engine to support full text search (Datastax Enterprise is built on top of Cassandra and has Apache Solr integration; you can also achieve something similar by writing an Elastic Search river that pulls data from Cassandra / is pushed data from your app or a Cassandra 2.1 Trigger). Note that with any full-text search indexing solution that is not directly tied to your primary data store, you can end up with consistency issues. The tradeoff is that by not directly tying your search indices in your database, you can scale each component separately (and deal with the consistency issue by manually pushing/pulling data into your search index). With Cassie plugins, it would be possible to add a pre/post save hook to add (push data) to your search index of choice and a model method (like Model.search) to query the search index instead of Cassandra.</p>

<p>Cassandra is not a graph database like neo4j or OrientDB, but you can apparently integrate Titan with Cassandra for Graph / Geolocation type queries.</p>

<p>Cassandra does not come with Map Reduce capabilities built in, but you can integrate with Apache Spark / Apache Hadoop for advanced Map Reduce queries / operations (Datastax Enterprise apparently comes with integrations for Hadoop).</p>

<p>See Data Modeling Notes and Common Examples for how to model common use cases (One-to-many modeling, Many-to-many modeling, transactions, pagination, etc.) and how to use Cassandra effectively.</p>

<div class="highlight highlight-javascript"><pre>
    <span class="pl-c">//Can't sort on name</span>
    <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">Number</span>, name<span class="pl-k">:</span> <span class="pl-c1">String</span>}, {primary<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>user_id<span class="pl-pds">'</span></span>]});
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
    User.<span class="pl-c1">find</span>({user_id<span class="pl-k">:</span> [<span class="pl-c1">1000</span>, <span class="pl-c1">1001</span>, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>]}).<span class="pl-c1">sort</span>({name<span class="pl-k">:</span> <span class="pl-c1">1</span>}).<span class="pl-c1">exec</span>(callback);

    <span class="pl-c">//Can't sort on name</span>
    <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">Number</span>, name<span class="pl-k">:</span> <span class="pl-c1">String</span>}, {primary<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>user_id<span class="pl-pds">'</span></span>]});
    UserSchema.<span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
    User.<span class="pl-c1">find</span>({user_id<span class="pl-k">:</span> [<span class="pl-c1">1000</span>, <span class="pl-c1">1001</span>, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>]}).<span class="pl-c1">sort</span>({name<span class="pl-k">:</span> <span class="pl-c1">1</span>}).<span class="pl-c1">exec</span>(callback);

    <span class="pl-c">//Can sort on name (Composite primary key)</span>
    <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">Number</span>, name<span class="pl-k">:</span> <span class="pl-c1">String</span>}, {primary<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>user_id<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>]});
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
    User.<span class="pl-c1">find</span>({user_id<span class="pl-k">:</span> [<span class="pl-c1">2000</span>, <span class="pl-c1">2001</span>, <span class="pl-c1">2002</span>, <span class="pl-c1">2003</span>]}).limit(<span class="pl-c1">10</span>).<span class="pl-c1">sort</span>({name<span class="pl-k">:</span> <span class="pl-c1">1</span>}).<span class="pl-c1">exec</span>(callback);

    <span class="pl-c">//Secondary index can only use '=' operator</span>
    <span class="pl-k">var</span> UserSchema <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Schema</span>({user_id<span class="pl-k">:</span> <span class="pl-c1">Number</span>, name<span class="pl-k">:</span> <span class="pl-c1">String</span>}, {primary<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>user_id<span class="pl-pds">'</span></span>]});
    UserSchema.<span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> User <span class="pl-k">=</span> cassie.model(<span class="pl-s"><span class="pl-pds">'</span>User<span class="pl-pds">'</span></span>, UserSchema);
    User.<span class="pl-c1">find</span>({name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>smith<span class="pl-pds">'</span></span>}, callback); <span class="pl-c">//Works</span>
    User.<span class="pl-c1">find</span>({name<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>smith<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>bob<span class="pl-pds">'</span></span>]}, callback); <span class="pl-c">//Doesn't work</span>
    User.<span class="pl-c1">find</span>({name<span class="pl-k">:</span> {$gt<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bob<span class="pl-pds">'</span></span>, $lt<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>smith<span class="pl-pds">'</span></span>}}, callback) <span class="pl-c">//Doesn't work</span>

</pre></div>

<h2>
<a id="why-cassandra" class="anchor" href="#why-cassandra" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why Cassandra</h2>

<p>Cassandra provides a truly distributed, fault tolerant design (kind of like an auto-sharded, auto-replicated, master-master database). Cassandra is designed so that if any one node goes down, you can create another node, attach it to the cluster, and retrieve the "lost" data without any downtime (based on your cluster settings). Cassandra provides linearly scalable reads and writes based on the number of nodes in a cluster (and is highly optimized for write throughput). In other words, when you need more reads/sec or writes/sec, you can simply add another node to the cluster. This means that your database can scale automatically similarly to how your API layer can (with good data modeling practices, some initialization scripts &amp; virtual machine tweaks of course).</p>

<p>If you follow good data modeling practices, (see "Data Modeling Notes"), you can do most queries that you would normally do in SQL databases or MongoDB using just CQL (some exceptions are full-text search, graph queries, map reduce jobs - see Elastic Search / Solr for search, Titan for graph queries, Apache Spark / Hadoop for map reduce jobs).</p>

<p>In addition, Cassandra is built with multi-datacenter support (across Wide Area Networks (WAN)).</p>

<p>Also see <a href="http://planetcassandra.org/what-is-apache-cassandra/">this</a>.</p>

<h2>
<a id="data-modelling-notes" class="anchor" href="#data-modelling-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Modelling Notes</h2>

<p>Datastax has tutorials on data modeling:</p>

<p><a href="http://www.datastax.com/resources/data-modeling">Datastax Data Modeling</a></p>

<p>In particular, see this one for common examples from traditional SQL Data modeling (One-to-many, Many-to-many, transactions): <a href="https://www.youtube.com/watch?v=px6U2n74q3g">Link</a></p>

<p>Its highly recommended that you view at least the above video and read these two tutorials on Cassandra Data Modeling before designing your models.</p>

<p><a href="http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1/#.U7YP_Y1dU_Q">Cassandra Data Modeling Best Practices Part 1 - Ebay Tech Blog</a>
<a href="http://www.ebaytechblog.com/2012/08/14/cassandra-data-modeling-best-practices-part-2/#.U7YQGI1dU_Q">Cassandra Data Modeling Best Practices Part 2 - Ebay Tech Blog</a></p>

<p>This is a powerpoint based on the above articles <a href="http://www.slideshare.net/jaykumarpatel/cassandra-data-modeling-best-practices">Cassandra Data Modeling Best Practices</a>.</p>

<p>In addition, take a look at some of Datastax's other tutorials:</p>

<p><a href="http://www.datastax.com/dev/tutorials">Datastax Cassandra Tutorials</a></p>

<h2>
<a id="not-yet-supported-on-roadmap" class="anchor" href="#not-yet-supported-on-roadmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not yet supported (on roadmap)</h2>

<p>Cassie Side:</p>

<ul>
<li>Hinting - node-cassandra-cql supports hinting (if you need to use it, use the node-cassandra-cql connection to make your query)</li>
<li>Collections - collection modifications - (UPDATE/REMOVE in single query with IN clause is supported, but Cassie doesn't do collection manipulation yet)</li>
<li>Proper collection updates - list &amp; map do not update accurately using Cassie (must manually use CQL for updates) - see <a href="https://www.youtube.com/watch?v=qphhxujn5Es">this video</a> from 10-16 minutes.</li>
<li>Queries loaded from external CQL files - <a href="https://github.com/godaddy/node-priam">node-priam</a> supports this currently, it also supports Fluent syntax for manual cql creation, and some other options for retry handling. Since Cassie is an ODM, it will probably not have "fluent syntax" for manual cql creation, but it does support plugins and can offer similar functionality through the "addQuery" method on Schemas.</li>
<li>Counters are not supported by Cassie (alternative is to use Integers or use the node-cassandra-cql connection to manually run queries or use the addQuery method on schemas)</li>
<li>Select COUNT(*) is not currently supported by Cassie (use raw cql query)</li>
<li>Change type of defined columns - should be possible, but need a translation layer between Cassandra's Java Marshaller classes and Cassie types</li>
<li>Stream rows - node-cassandra-cql supports it (connection.eachRows), but it was failing in Cassie's tests, so its not included at the moment (stream is included though and performs a similar function)</li>
<li>Advanced table creation options - Not currently supported by cassie (alternative is to use ALTER TABLE in cqlsh or create table manually in cqlsh)</li>
<li>Paging - Generic Paging support is not quite ready yet (to use client side paging, see "Data Modeling Notes"). Also see driver issue below.</li>
</ul>

<p>Plugins / Other useful functionality (separate repos, build on top of cassie or as cassie-plugins):</p>

<ul>
<li>Elastic Search Plugin (cassie-elastic-search-plugin) - for async pushing of Cassie models to elastic search index and querying said index (note can lead to consistency issues if push to elastic search fails in a post-save scenario)</li>
<li>Sessions (connect-cassie) - Create CassieStore to store user sessions</li>
<li><p>Easy Performance Testing - Expand timing, debugging and modeling to support quick testing of query performance on test clusters to simulate real client load</p></li>
<li><p>Testing Update with TTL</p></li>
<li><p>Migrating all tests to automated testing with Mocha / Istanbul (see readme-tests directory)</p></li>
<li><p>Not on roadmap: Connecting to multiple keyspaces (ie keyspace multi-tenancy with one app) - Can currently use a new connection and manually run CQL, but can't sync over multiple keyspaces because schemas and models are tied to a single cassie instance. Current way to deal with this is to use a separate server process (ie a different express/nodejs server process) and don't do multitenancy over multiple keyspaces in the same server process.</p></li>
</ul>

<p>Driver Side:</p>

<ul>
<li>Paging - Cassie supports rudimentary client side paging where the token and a count is provided, but the node-cassandra-cql driver doesn't seem to have support for native paging yet (as of v0.5.0). It seems to be in node-cassandra-cql master on github, but not in released versions.</li>
<li>Input Streaming - not supported by node-cassandra-cql yet</li>
<li>SSL Connections - not supported by node-cassandra-cql yet</li>
<li>Auto determine other hosts - not supported by node-cassandra-cql yet</li>
<li>"Smart connections" - Only send CQL request to the hosts that contain the data (requires knowing about how the data is sharded, apparently Netflix uses something like this) - this might have to be based on your Schemas &amp; how Cassandra is handling the sharding based on partition key. Naive Hypothesis: It might be possible by querying the system keyspace in Cassandra to determine which hosts contain the relevant shard keys periodically.</li>
<li>Possibly switch to officially supported native C/C++ driver when out of beta (would need to test performance, wrap C functions in javascript, and possibly do Javascript type to C type conversions / hinting in Cassie) - <a href="https://github.com/datastax/cpp-driver">https://github.com/datastax/cpp-driver</a> and see Apache JIRA for project (note that this would mean making a node module like hiredis that compiles C/C++ code on multiple platforms)</li>
</ul>

<h2>
<a id="testing--development" class="anchor" href="#testing--development" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing &amp; Development</h2>

<p>Pre-reqs:
Nodejs installed and a Cassandra server running on localhost:9042
Clone the repository and run the following from command line:</p>

<pre><code>
    npm install &amp;&amp; npm test

</code></pre>

<p>Note: 'npm test' creates a keyspace "cassietest" on your local Cassandra server then deletes it when done.</p>

<p>Get code coverage reports by running 'npm run test-coverage' (coverage reports will go into /coverage directory - these reports are not exactly accurate because they don't take into account tests in the /readme-tests directory - see roadmap).</p>

<p>Submit pull requests for any bug fixes and add issues if you encounter them!</p>

<h2>
<a id="more-information-about-cassandra-including-installation-guides-production-setups-and-data-modeling-best-practices" class="anchor" href="#more-information-about-cassandra-including-installation-guides-production-setups-and-data-modeling-best-practices" aria-hidden="true"><span class="octicon octicon-link"></span></a>More information about Cassandra including Installation Guides, Production Setups, and Data Modeling Best Practices</h2>

<p>For information on Cassandra, go to the <a href="http://cassandra.apache.org/">Apache Cassandra homepage</a>.</p>

<p>For information on CQL, see <a href="http://www.datastax.com/documentation/cql/3.1/cql/cql_intro_c.html">Cassandra 2.0 CQL Reference</a></p>

<p>For information on Cassandra's fault-tolerant, distributed architecture, see <a href="http://www.datastax.com/documentation/articles/cassandra/cassandrathenandnow.html">the original Facebook whitepaper on Cassandra annotated with differences</a>. Alternatively, also read Google's <a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf">BigTable architecture whitepaper</a> and <a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Amazon's Dynamo whitepaper</a> as Cassandra's design was influenced by both.</p>

<p>For helpful tips on data modeling in Cassandra (particularly if you come from a SQL background), see these links:</p>

<ul>
<li><a href="http://www.datastax.com/resources/data-modeling">Datastax Data Modeling</a></li>
<li><a href="http://www.datastax.com/dev/tutorials">Datastax Cassandra Tutorials</a></li>
<li><a href="http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1/#.U7YP_Y1dU_Q">Cassandra Data Modeling Best Practices Part 1 - Ebay Tech Blog</a></li>
<li><a href="http://www.ebaytechblog.com/2012/08/14/cassandra-data-modeling-best-practices-part-2/#.U7YQGI1dU_Q">Cassandra Data Modeling Best Practices Part 2 - Ebay Tech Blog</a></li>
</ul>

<p>Other databases to look at if Cassandra doesn't fit your data needs: MySQL, PostgreSQL, MongoDB, Riak, neo4j, Oracle, Microsoft SQL Server.</p>

<p>Some options to use if Cassandra doesn't support your query needs: Elastic Search / Solr for search indices, Titan for graph queries, Apache Spark / Apache Hadoop for map reduce operations, Apache Storm for general distributed data processing.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>LICENSE</h2>

<p>The MIT License</p>

<p>Copyright (c) 2014 Suyog Sonwalkar <a href="mailto:flux159@gmail.com">flux159@gmail.com</a></p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Flux159/cassie-odm">cassie-odm</a> is maintained by <a href="https://github.com/Flux159">Flux159</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-47539617-6");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>

