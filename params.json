{"name":"cassie-odm","tagline":"Lightweight Nodejs Object Model Layer for Apache Cassandra","body":"Cassie\r\n=====\r\nCassie is a lightweight model layer and CQL generator written in javascript that uses the [node-cassandra-cql](https://github.com/jorgebay/node-cassandra-cql) project and attempts to mimic most of mongoose's API to allow for relatively easy switching between MongoDB and Cassandra. Cassie is a small module written completely in javascript and has a small dependency tree. Cassie supports data modeling, syncing tables, standard CRUD operations, Validations, Hooks, Plugins, Lightweight Transactions, Time to Live queries, batching, streaming queries, timing, and debugging queries (with 'pretty debugging' for supported terminals). Note that Cassie-ODM is not currently a full 1:1 mapping to mongoose's API.\r\n\r\nCassie is currently in beta (as of v0.1.0). Use at your own risk in production environments.\r\n\r\nInstalling\r\n----------\r\nIf you have nodejs installed, just run the following in your project's directory:\r\n\r\n```\r\n    npm install cassie-odm\r\n```\r\n\r\nAlso note that to use any of the examples below, it is assumed that you have Cassandra downloaded and running (default port of 9042). See the [Apache Cassandra Download](http://cassandra.apache.org/download/) page for how to install Cassandra. Alternatively, get Cassandra from the [Datastax Community Distribution](http://planetcassandra.org/cassandra/). For OSX, you can install Cassandra from homebrew (see [this](http://christopher-batey.blogspot.com/2013/05/installing-cassandra-on-mac-os-x.html)). For debian based systems (Ubuntu), you can install from apt-get.\r\n\r\nGetting Started\r\n----------\r\n```javascript\r\n\r\n    var cassie = require('cassie-odm');\r\n    var config = {keyspace: \"CassieTest\", hosts: [\"127.0.0.1:9042\"]};\r\n    cassie.connect(config);\r\n    \r\n    var CatSchema = new cassie.Schema({name: String});\r\n    var Cat = cassie.model('Cat', CatSchema);\r\n    \r\n    cassie.syncTables(config, function(err, results) {\r\n    \r\n        var kitty = new Cat({ name: 'Eevee'});\r\n        kitty.save(function(err) {\r\n            if(err) return console.log(err);\r\n            console.log(\"meow\");\r\n            cassie.close();\r\n        });\r\n        \r\n    });\r\n    \r\n\r\n```\r\n\r\nModeling\r\n---------\r\nModeling is the process of defining your Schemas. Although Cassandra is a NoSQL database, it is required to make a column family with a primary key. Cassie makes this process easier by helping you organize your code by defining Schemas in a single location (for easy reference). If you do not specify a primary key, Cassie will automatically generate an 'id' key for you. Modeling also allows you to perform validations and apply pre and post hooks to your models. Finally, Cassie will actually sync your tables forward to make rapid development easier ( tables and fields that don't exist in Cassandra will be created. Cassie does not delete tables or fields as this could lead to data loss. Cassie can warn you if there are unused fields though, see the \"Sync\" section for more information).\r\n\r\n```javascript\r\n\r\n    var cassie = require('cassie-odm'),\r\n        Schema = cassie.Schema; //Require cassie module\r\n\r\n    var config = {keyspace: \"CassieTest\", hosts: [\"127.0.0.1:9042\"]};\r\n    cassie.connect(config); //Connect to local cassandra server\r\n\r\n    //User Schema\r\n    var UserSchema = new Schema({\r\n        username: String,\r\n        email: {type: String, required: true},\r\n        hashed_password: {type: String, required: true},\r\n        blogs: [cassie.types.uuid]});\r\n\r\n    //Adds a validator for username\r\n    UserSchema.validate('username', function (user) {\r\n        return (user.username !== null);\r\n    }, \"Username cannot be empty.\");\r\n\r\n    //Add a post-save hook\r\n    UserSchema.post('save', function (model) {\r\n        console.log(\"A new user signed up!\");\r\n    });\r\n\r\n    //Blog Schema\r\n    var BlogSchema = new Schema({title: {type: String, required: true}, content: String, author: String});\r\n\r\n    //Registers the schemas with cassie\r\n    var User = cassie.model('User', UserSchema);\r\n    var Blog = cassie.model('Blog', BlogSchema);\r\n\r\n    //Sync the schemas with Cassandra to ensure that they exist and contain the appropriate fields (see additional notes on the limitations of syncing)\r\n    var syncOptions = {debug: true, prettyDebug: true, warning: true};\r\n    cassie.syncTables(config, syncOptions, function (err, results) {\r\n        console.log(err);\r\n\r\n        //Creates a new user\r\n        var newUser = new User({username: 'ManBearPig', email: 'AlGore@gmail.com', hashed_password: 'Never-do-this-use-crypto-module'});\r\n\r\n        //Asynchronous function that returns to provided callback\r\n        newUser.save({debug: true, prettyDebug: true}, function (err, results) {\r\n            if (err) console.log(err);\r\n\r\n            //Creates a new blog\r\n            var newBlog = new Blog({title: 'Global warming and Manbearpig', content: 'Half-man, half-bear, half-pig...', author: newUser.username});\r\n\r\n            //.save() without a callback returns a Query object. Here we batch together multiple queries to execute them together\r\n            var firstQuery = newBlog.save();\r\n\r\n            //Note that for types other than arrays and maps, cassie tracks changes for saving, however, since blogs is an array, we need to mark it as modified\r\n            //Also note that after running .save(), newBlog has a generated field called 'id'. This only occurs if cassie created the primary key for us (see \"Primary Keys\" for more info).\r\n            newUser.blogs.push(newBlog.id);\r\n            newUser.markModified('blogs');\r\n\r\n            //Get second query to batch\r\n            var secondQuery = newUser.save();\r\n\r\n            //Run batch cql commands\r\n            cassie.batch([firstQuery, secondQuery], {consistency: cassie.consistencies.quorum, debug: true, prettyDebug: true}, function (err, results) {\r\n                if (err) console.log(err);\r\n\r\n                //Close the connection since we're done\r\n                cassie.close();\r\n            });\r\n        });\r\n\r\n    });\r\n\r\n\r\n```\r\n\r\nThe above example shows a lot of code, but is relatively simple to understand (particularly if you've used Mongoose). First, we connect to the Cassandra server. Then, we create some schemas with cassie (along with a validator for username and a post-save hook on users). After we register the Schemas with cassie, we sync the tables to make sure that Cassandra knows that they exist (see \"Sync\" for more information on this and the limitations of syncing). Also note that we haven't provided a primary key in any of our schemas. In general, its good practice to explicitly define a primary key in Cassandra (and Cassandra requires it actually). Cassie takes care of this requirement by generating a field called 'id' if we don't specify a primary key. After we call the sync tables function, we can now create users and blogs in our database. First, we create a new user and save it. Then we create a new blog and store the query to be called with some other updates. Once we've done our updates locally, we gather the queries and send them in a batch to our Cassandra server using the cassie.batch command to create our blog post and update our user. Finally, we close the connection when we're done.\r\n\r\nNOTE: All fields should be lowercase. This is due to Cassandra's columns being lowercase (and currently Cassie doesn't automatically covert these for you in javascript).\r\n\r\nSome things to note about the above example:\r\n    First, all fields inside of models must be lowercase. This is because when creating fields in Cassandra through CQL, fields are stored without any uppercase letters. Second, never store a password in plain text, ideally, you would use the crypto module to generate a hash of the user's password and store that in your database. Finally, this data model is not very efficient for a number of reasons that would make more sense if you read through the \"Data Modeling Notes\" and Cassandra's documentation / architecture (not posting here for brevity).\r\n\r\nQueries\r\n----------\r\nConstruct and run CQL queries by passing arguments or chaining methods. See the following sections for basic CRUD operations.\r\n\r\nCRUD (Create, Read, Update, Delete) Operations\r\n----------\r\nCreate, Read, Update, Delete operations on Models.\r\n\r\n```javascript\r\n\r\n    //Schema used for CRUD examples:\r\n    \r\n    var FishSchema = new Schema({\r\n        fish_id: {type: Number, primary: true},\r\n        name: String\r\n    });\r\n    \r\n    cassie.model('Fish', FishSchema);\r\n\r\n```\r\n\r\nCreate Example (INSERT):\r\n\r\n```javascript\r\n\r\n    //Create Example (assuming schemas have been defined and sync'ed - see sync for more information)\r\n    var Fish = cassie.model('Fish');\r\n\r\n    var fishee = new Fish({fish_id: 2001, name: 'eevee'});\r\n    fishee.save(function(err) {\r\n        //Handle errors, etc.\r\n    });\r\n\r\n```\r\n\r\nRead Example (SELECT):\r\n\r\n```javascript\r\n\r\n    //Read Example (assuming schemas have been defined & sync'ed - see sync for more information)\r\n    var Fish = cassie.model('Fish');\r\n\r\n    Fish.find({fish_id: {$in: [2000, 2001, 2002, 2003, 2004]}}).exec(function(err, fishes) {\r\n\t\t\t\t//Note: fishes is an array\r\n        console.log(fishes.toString());\r\n        var firstFish = fishes[0]; //...\r\n    });\r\n\r\n\r\n```\r\n\r\nRead Example 2 (SELECT LIMIT 1 - findOne):\r\n\r\n```javascript\r\n\tvar Fish = cassie.model('Fish');\r\n\r\n\tFish.findOne({fish_id: 2000}, function(err, fish) {\r\n\t\t\t//Note: fish is a single object\r\n\t\t\tconsole.log(fish.toString());\r\n\t});\r\n\r\n```\r\n\r\nUpdate Example (UPDATE):\r\nNote: Cassie internally stores a flag to know when you've modified fields - for arrays and maps, you must specified that a field has been modified using the Model.markModified('fieldName'); method though (see 'Modeling' for an example)\r\n\r\n```javascript\r\n\r\n    //Update Example (assuming schemas have been defined & sync'ed - see sync for more information)\r\n\r\n    var Fish = cassie.model('Fish');\r\n\r\n    var fishee2 = new Fish({fish_id: 2002, name: 'eevee'});\r\n    fishee2.save(function(err) {\r\n\r\n        //Renaming the fish\r\n        fishee2.name = 'bambie';\r\n\r\n        fishee2.save(function(err) {\r\n            //fishee2 has now been renamed (Cassie internally stores a flag to know when you've modified fields - for arrays and maps, you must specified that a field has been modified using the fishee2.markModified('fieldName'); method though (see 'Modeling' for an example).\r\n        });\r\n    });\r\n\r\n    //Alternatively, you can also send update queries if you know some information about the model\r\n\r\n    var Fish = cassie.model('Fish');\r\n    var fish_id3 = 2003; //Assumes fish_id is a number. If uuid, would need to pass uuid as a string\r\n\r\n    Fish.update({fish_id: fish_id3}, {name: 'bambie'}, function(err) {\r\n        if(err) console.log(err);\r\n        //Fish with id 2000 has had its name updated\r\n        //If no fish with id exists, returns error\r\n    });\r\n\r\n    //Fish.update can also take multiple ids in the same way as find: {id: {$in: [1234,1235]} or {id: [1234,1235]}\r\n\r\n```\r\n\r\nDelete Example (DELETE):\r\n\r\n```javascript\r\n\r\n    //Delete Example (assuming schemas have been defined & sync'ed - see sync for more information)\r\n\r\n    var Fish = cassie.model('Fish');\r\n\r\n    var fishee4 = new Fish({fish_id: 2004, name: 'goldee'});\r\n    fishee4.save(function(err) {\r\n        if(err) console.log(err);\r\n\r\n        fishee4.remove(function(err) {\r\n            if(err) console.log(err);\r\n            //Fishee has been removed.\r\n        });\r\n    });\r\n\r\n    //Alternatively, you can also send delete queries if you know some information about the model (that Cassandra indexes by)\r\n\r\n    var Fish = cassie.model('Fish');\r\n    var fish_id5 = 2005; //Assumes fish_id is a number. If uuid, would need to pass uuid as a string\r\n\r\n    Fish.remove({fish_id: fish_id5}, 'name', function(err) {\r\n        if(err) console.log(err);\r\n        //Fish with id 2001 has had its name deleted\r\n    });\r\n\r\n    //To delete entire row, ignore second argument. Ex:\r\n    //Fish.remove({id: fish_id5}, function(err) {\r\n    //Your callback code\r\n    //});\r\n\r\n    //Fish.remove can also take multiple ids in the same way as find: {id: {$in: [1234,1235]} or {id: [1234,1235]}\r\n\r\n```\r\n\r\n\r\nTypes\r\n----------\r\nCassie supports the following types. Note that arrays and Maps must have defined types.\r\n\r\nString\r\nNumber (can specify Int by using cassie.types.Int, Double by cassie.types.Double, or Long by cassie.types.Long) - default is Int if you use Number\r\nDate (a timestamp)\r\nObjectId (specified by cassie.types.ObjectId or cassie.types.uuid) - this is a uuid v4\r\nBuffer (Cassandra stores as blobs)\r\nArrays (must specify internal type, like: [String])\r\nMaps (must specify internal types, like {String: String} - arbitrary maps are not supported, use Buffers (Blobs) instead)\r\n\r\nSync\r\n----------\r\n\r\nSyncing is the process of creating keyspaces (similar to a database in traditional RDBMs) and column families (similar to tables) from your schemas. Cassie handles the process of syncing via its syncTables function. Sync tables will create a keyspace if it doesn't exist, create column families if they don't exist, and alter column families if you've added fields to your schemas. Syncing also creates a primary key with the name of 'id' if you don't specify a different primary key. This allows you to rapidly iterate on modifying your schemas and keep your tables in sync. \r\n\r\nHowever, syncing has some limitations in its current form. \r\n\r\nSyncing cannot alter column names, so if you decide to change your column name, you would have to use cqlsh (see CQL documentation on ALTER TABLE with the RENAME clause [here](http://www.datastax.com/documentation/cql/3.0/cql/cql_reference/alter_table_r.html). This is because cassie doesn't know what you previously defined a column as (and it has no way of knowing that information).\r\n\r\nCassie cannot change the types of already defined columns. This is currently a limitation of Cassie's sync function and may be added later (see roadmap). \r\n\r\nCassie also cannot change the primary key for any table after it has been created (ie you must define your schemas according to query patterns for Cassandra to be effective, see \"Data Modeling Notes\"). This is a limitation of Cassandra.\r\n\r\nFinally, Cassie does not delete columns or tables from your database if they aren't defined. You can pass a \"warning: true\" option to sync tables to tell you which columns are missing from your schemas, but Cassie will not delete the columns for you (to prevent unintended data loss). This is what \"syncing forward\" implies.\r\n\r\nNOTE: Make sure to read about \"Keyspace Replication Strategies and Production Notes\" if you intend on using Cassandra in Production. It is required to understand replication strategies for production, particularly for automated deployment setups.\r\n\r\nNOTE: Currently Cassie generates a table name by using a lowercase pluralized version of the Model name you specify (ie 'User' becomes 'users').\r\n\r\nHere is an example of using sync tables to sync two tables to the database with debugging and warning flags enabled:\r\n\r\n```javascript\r\n\r\n        var cassie = require('../../lib/cassie'),\r\n            Schema = cassie.Schema; //Require cassie module\r\n\r\n        var config = {keyspace: \"CassieTest\", hosts: [\"127.0.0.1:9042\"]};\r\n        cassie.connect(config); //Connect to local cassandra server\r\n\r\n        //User Schema\r\n        var UserSchema = new Schema({\r\n            username: String,\r\n            email: {type: String, required: true},\r\n            hashed_password: {type: String, required: true},\r\n            blogs: [cassie.types.uuid]});\r\n\r\n        //Blog Schema\r\n        var BlogSchema = new Schema({title: {type: String, required: true}, content: String, author: String});\r\n\r\n        //Registers the schemas with cassie\r\n        var User = cassie.model('User', UserSchema);\r\n        var Blog = cassie.model('Blog', BlogSchema);\r\n        \r\n        var syncOptions = {debug: true, prettyDebug: true, warning: true};\r\n        cassie.syncTables(config, syncOptions, function (err) {\r\n            console.log(err);\r\n        });\r\n\r\n```\r\n\r\nWhen writing an application, the general idea is that you preload all your schemas into cassie, then sync your models once before running your other code (ie before starting an express application or web server). This will give you access to all your models whenever you need them by using the cassie.model('ModelName') function. This is similar to how Mongoose handles preloading schemas.\r\n\r\nA final thing to note is that you can specify Keyspace replication strategy's in your Cassie config (if you let Cassie create your keyspaces for you - you can do this yourself through cqlsh, but Cassie can automate the process as well). See \"Keyspace Replication Strategy and Production Notes\" for more information.\r\n\r\nTable Creation Options when syncing\r\n----------\r\n\r\n\"See Advanced Table Creation Options\"\r\n\r\nPrimary Keys\r\n----------\r\nCassandra requires a primary key for all column families. This means that you would need to define a primary key whenever creating a table. Cassie relaxes that restriction slightly by allowing you to define Schemas without primary keys. However, what Cassie does internally is create an 'id' field on your Schema and adds a pre-save hook to generate an id for all new models (see \"Hooks\" for how you can do the same with your own fields). Cassie then marks this 'id' field as your primary key. This is important to note because primary keys cannot be modified using an ALTER TABLE command. In Cassandra, once your primary key has been set for a table, you're not allowed to modify it. If you want sophisticated primary keys (like composite primary keys), you need to design your Data Model appropriately from the beginning and make sure that you define it correctly in your Schema.\r\n \r\n See \"Data Modeling\" notes for more information on designing appropriate models for common use cases. Take particular note of how composite primary keys can be used for quick advanced queries.\r\n\r\nThe examples below show how a primary key can be explicitly defined on a field, how a composite primary key can be defined, and how to allow Cassie to generate a primary key for you:\r\n\r\n```javascript\r\n\r\n    //Explicitly defining a primary key\r\n    var DogSchema = new Schema({\r\n        'dog_id': {type: Number, primary: true},\r\n        'fname': String,\r\n        'lname': String\r\n    });\r\n    \r\n    //Explicitly defining a composite primary key\r\n    var DogeSchema = new Schema({\r\n        'dog_id': {type: Number},\r\n        'fname': String,\r\n        'lname': String\r\n    }, {primary: ['dog_id', 'fname']});\r\n    \r\n    //Explicitly defining a composite primary key and partition key (row key is based on dog_id and fname)\r\n    var DawgSchema = new Schema({\r\n        'dog_id': {type: Number},\r\n        'fname': String,\r\n        'lname': String\r\n    }, {primary: [['dog_id','fname'], 'lname']});\r\n    \r\n    //Cassie defines 'id' field for you - Note that in this case 'dog_id' is NOT the primary key, 'id' is (and 'id' is a uuid v4 type)\r\n    //Cassie will also add a presave function that adds the 'id' field for you before you save a new model.\r\n    var DagSchema = new Schema({\r\n        'dog_id': {type: Number, default: 'uuid'},\r\n        'fname': String,\r\n        'lname': String\r\n    });\r\n\r\n```\r\n\r\nSecondary Indexing\r\n----------\r\nCassie supports secondary indexes on fields with the following option {index: true}. See the example below:\r\n\r\n```javascript\r\n    //Explicitly defining a primary key and defining a secondary index\r\n    var DogSchema = new Schema({\r\n        'dog_id': {type: Number, primary: true},\r\n        'fname': {type: String, index: true},\r\n        'lname': String\r\n    });\r\n    \r\n    //Alternative way of defining a secondary index\r\n    DogSchema.index('lname');\r\n```\r\n\r\nValidations\r\n----------\r\nValidations are a core part of Cassie's Object Data Model. Validations allow you to easily reject inserts and updates across all your models in javascript without ever hitting your database. Cassie comes with internal support for a \"required\" validation and also allows you to validate any field with a custom function.\r\n\r\n```javascript\r\n\r\n    //Requiring that 'fname' is provided (is not null)\r\n    var DogSchema = new Schema({\r\n        'dog_id': {type: Number, primary: true},\r\n        'fname': {type: String, required: true},\r\n        'lname': String\r\n    });\r\n\r\n    //Adding a custom validation to 'lname'\r\n    DogSchema.validate('lname', function(model, fieldKey) {\r\n        return (model[fieldKey] === 'doge');\r\n    }, \"Last name is required.\");\r\n\r\n    //A validate function is passed the model and the fieldKey to validate. It returns true or false.\r\n    //The validation function above requires that 'lname' is equal to 'doge' for all models\r\n\r\n```\r\n\r\nHooks\r\n----------\r\n\r\nCassie supports pre-save and pre-remove hooks for its models. It also supports post-init, post-validate, post-save, and post-remove hooks. The example below shows all of these being used.\r\n\r\n```javascript\r\n\r\n    var TrickSchema = new Schema({'name': {type: String, index: true}});\r\n    \r\n    TrickSchema.post('init', function (model) {\r\n        console.log(\"Initialized Trick\");\r\n    });\r\n    \r\n    TrickSchema.post('validate', function (model) {\r\n        console.log(\"Validated Trick\");\r\n    });\r\n    \r\n    TrickSchema.pre('save', function (model) {\r\n        console.log(\"About to save (insert or update) trick to database\");\r\n    });\r\n    \r\n    TrickSchema.post('save', function (model, err, results) {\r\n        if(!err) console.log(\"Saved Trick to database\");\r\n    });\r\n    \r\n    TrickSchema.pre('remove', function (model) {\r\n        console.log(\"About to remove trick (or trick fields) from database\");\r\n    });\r\n    \r\n    TrickSchema.post('remove', function (model, err, results) {\r\n        if(!err) console.log(\"Removed trick (or trick fields) from database\");\r\n    });\r\n    \r\n    cassie.model('Trick', TrickSchema);\r\n\r\n```\r\n\r\nNote that hooks are only called on Cassie object instances, not when performing Model.update or Model.remove (because those are direct database calls that don't generate any Cassie instances).\r\n\r\nPlugins\r\n----------\r\nModels support plugins. Plugins allow you to share schema properties between models and allow for pre-save hooks, validations, indexes, pretty much anything you can do with a Schema. Note that you can't modify primary keys or add primary keys in a plugin.\r\n\r\n```javascript\r\n    \r\n    //updatedAtPlugin.js\r\n    function updatedAtPlugin(schema, options) {\r\n        schema.add({updated_at: Date}); //Adds a field to the model instance\r\n    \r\n        schema.addQuery({'get': function(args, callback) {\r\n            console.log(\"Inside Model get function\");\r\n            var results = args;\r\n            callback(results);\r\n        }});\r\n        //Adds a function to query by on Model class (like Model.find, Model.update, Model.remove)\r\n        //This can be useful when making plugins that add query logic to a Model class\r\n        //Example: Integrate an external data source / index in a plugin (like a search index), then add a method that will query that external data source\r\n        //Combining pre/post save logic and queries can allow for expressive plugins\r\n    \r\n        schema.pre('save', function(model) {\r\n            model.updated_at = new Date();\r\n        });\r\n    \r\n        if(options && options.index) {\r\n            schema.index('updated_at');\r\n        }\r\n    }\r\n    \r\n    //user.js\r\n    //var updatedAtPlugin = require('./updatedAtPlugin');\r\n    var UserSchema = new Schema({name: String});\r\n    UserSchema.plugin(updatedAtPlugin, {index: true});\r\n    \r\n    //blog.js\r\n    //var updatedAtPlugin = require('./updatedAtPlugin');\r\n    var BlogSchema = new Schema({title: String});\r\n    BlogSchema.plugin(updatedAtPlugin, {index: true});\r\n    \r\n    var User = cassie.model('User', UserSchema);\r\n    var Blog = cassie.model('Blog', BlogSchema);\r\n\r\n    //Can now perform queries like:\r\n    User.get('args', function(results) {\r\n        console.log(results);\r\n    });\r\n\r\n```\r\n\r\nLightweight Transactions\r\n----------\r\n\r\nCassie supports lightweight transactions for saving new data via the {if_not_exists: Boolean} option.\r\n\r\nFor updating data, you can use the IF field = 'value' CQL command by passing {if: {field: value}} as an option to save.\r\n\r\n```javascript\r\n\r\n    var User = cassie.model('User');\r\n    \r\n    //Assumption is that user_id is primary key\r\n    var new_user = new User({user_id: 2000, name: 'steve'});\r\n    \r\n    new_user.save({if_not_exists: true}, function(err) {\r\n        //Handle errors, etc.\r\n        \r\n        //Same user using IF field = value\r\n        new_user.name = \"bill\";\r\n        \r\n        new_user.save({if: {name: 'bob'}, debug: true}, function(err) {\r\n            \r\n            //Handle errors, etc.\r\n            //Note that this query will not update new_user because new_user's name is not 'bob'\r\n        \r\n        });\r\n        \r\n    });\r\n    \r\n\r\n```\r\n\r\n\r\nTime to Live (TTL)\r\n----------\r\nCassie supports specifying a TTL when inserting data via the {ttl: Number} option, where Number is the time in seconds. Also see \"Sessions\".\r\n\r\n```javascript\r\n\r\n    var Post = cassie.model('Post');\r\n    \r\n    var new_post = new Post({title: 'My time limited post'});\r\n\r\n    new_post.save({ttl: 86400}, function(err) {\r\n        //Handle errors, etc.\r\n    });\r\n\r\n```\r\n\r\nLimit & Sorting\r\n----------\r\nCassie can limit your queries based on options or by chaining queries. See the examples below:\r\n\r\n```javascript\r\n\r\n    var User = cassie.model('User');\r\n    \r\n    User.find({}, {limit: 10, sort: {name: 1}}, function(err, users) {\r\n        console.log(users.toString());\r\n    });\r\n    \r\n    //Same query as above using chaining\r\n    User.find({}).limit(10).sort({name: 1}).exec(function(err, users) {\r\n        console.log(users.toString());\r\n    });\r\n    \r\n\r\n```\r\n\r\nBatching\r\n----------\r\nCassie can batch queries together to run at once. This is done by not specifying a callback to an insert or delete function and passing an array of queries to cassie.batch(). See the example below:\r\n\r\n```javascript\r\n\r\n    var new_user_1 = new User({user_id: 1000, name: 'Bob'});\r\n    var new_user_2 = new User({user_id: 2000, name: 'Steve'});\r\n\r\n    var query_1 = new_user_1.save();\r\n    var query_2 = new_user_2.save();\r\n\r\n    var batchOptions = {debug: true, prettyDebug: true, timing: true};\r\n    cassie.batch([query_1, query_2], batchOptions, function(err) {\r\n        //Handle errors, etc.\r\n        if(err) console.log(err);\r\n    });\r\n    \r\n\r\n```\r\n\r\nExecute Prepared\r\n----------\r\nCassie can execute prepared queries by passing in a \"prepared\" option when calling exec (either through a callback or through Query.exec() directly). See the examples below:\r\n\r\n```javascript\r\n\r\n    var User = cassie.model('User');\r\n    \r\n    User.find({user_id: {$in: [1000, 1001, 1002, 1003]}}, {prepared: true}, function(err, users) {\r\n        //Handle errors, do stuff w/ results\r\n    });\r\n    \r\n    //This is equivalent to the above\r\n    var query = User.find({user_id: {$in: [1000, 1001, 1002, 1003]}});\r\n    query.exec({prepared: true}, function(err, users) {\r\n        //Handle errors, do stuff w/ results\r\n    });\r\n\r\n```\r\n\r\nStreaming\r\n----------\r\nCassie supports streaming results via a Query.stream(options, callback) method. This returns a readable stream (can view documentation for node-cassandra-cql streams as well). See the example below:\r\n\r\n```javascript\r\n\r\n    var User = cassie.model('User');\r\n    \r\n    var query = User.find({user_id: {$in: [1000, 1001, 1002, 1003]}});\r\n    query.stream()\r\n        .on('readable', function() {\r\n            var row;\r\n            while(row = this.read()) {\r\n                console.log(row);\r\n            }\r\n        })\r\n        .on('end', function() {\r\n            //Stream ended\r\n            console.log(\"Stream ended\");\r\n            cassie.close();\r\n        })\r\n        .on('error', function(err) {\r\n            //Stream error\r\n            console.log(err);\r\n        });\r\n\r\n```\r\n\r\nTiming, Debugging, and Logging\r\n----------\r\nCassie supports timing and debugging capabilities (including a prettyDebug mode which prints using colored text to a supported terminal and is far more human readable than standard debugging). These options are supported on almost all Cassie queries (timing is not supported on sync tables because it should really only be called once after preloading all your schemas). To use the options, simply pass the following object to a query as part of its options:\r\n\r\n```javascript\r\n\r\n    var options = {debug: true, timing: true, prettyDebug: true};\r\n    \r\n    //Examples\r\n    \r\n    //User.find({}, options, callback);\r\n\r\n    //var user = new User({name: 'Steve'});\r\n    //user.save(options, callback);\r\n    \r\n    //var query = user.save();\r\n    //query.exec(options, callback);\r\n\r\n```\r\n\r\nNote that pretty debugging should not be used for logs as it uses escaped characters to print in color (google ASCII color codes). It is primarily useful for development purposes.\r\n\r\nYou can also pass a logger like [winston](https://github.com/flatiron/winston) in by providing the winston object in the \"logger\" property.\r\n\r\n```javascript\r\n    var winston = require('winston');\r\n    var options = {debug: true, timing: true, logger: winston};\r\n```\r\n\r\nClient Connections and raw queries\r\n----------\r\nClient connections are handled by node-cassandra-cql. Cassie encapsulates a connection internally, but you can also use the node-cassandra-cql connection directly for CQL queries:\r\n\r\n```javascript\r\n\r\n    var cassie = require('cassie-odm');\r\n    var connection = cassie.connect({keyspace: \"mykeyspace\", hosts: [\"127.0.0.1:9042\"]});\r\n    \r\n    connection.execute(\"SELECT * FROM cats\", [], function(err, results) {\r\n        if(err) return console.log(err);\r\n        console.log(\"meow\");\r\n    });\r\n    \r\n```\r\n\r\nAdvanced Table Creation Options\r\n----------\r\nThere are a few queries that can be efficiently executed if you use on-disk sorting of columns when creating tables. Cassie allows you to specify options for creating tables when defining your schemas. See \"Data Modeling Notes\" for more information on efficient client queries. See [Using Clustering Order](http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/refClstrOrdr.html) for Clustering Order option. Cassie only supports the clustering order option at the moment (adding all table properties is on the roadmap, you can modify them manually currently using CQL's ALTER TABLE command).\r\n\r\nSee [CQL Create Table documentation](http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/create_table_r.html) and [CQL Table Properties](http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/tabProp.html) for all the advanced options. \r\n\r\n```javascript\r\n\r\nvar EventSchema = new Schema({\r\n        event_type: String,\r\n        insertion_time: cassie.types.Timestamp,\r\n        event: cassie.types.Blob\r\n    },\r\n    {\r\n        primary: ['event_type', 'insertion_time'],\r\n        create_options: {\r\n            clustering_order: {'insertion_time': -1}\r\n        }\r\n    });\r\n\r\n```\r\n\r\n\r\nKeyspace Replication Strategy and Production notes\r\n----------\r\n\r\nBy default, cassie assumes that you are developing locally and creates keyspaces with a \"Simple Replication Strategy\" and a replication factor of 1. This is not ideal for a production setup. A production Cassandra cluster will generally have a minimum of 3 nodes, a \"Network Topology Replication Strategy\" and a replication factor of 3. What this means is that you have 3 instances of Cassandra running (generally on separate servers). This allows you to survive the loss of one of the servers without losing your data (and once a third node is added back, Cassandra will automatically populate the node with the data it needs). Since cassie can create keyspaces, it needs to know what strategy to use when creating the keyspace. It does this by checking for options in your connection configuration. Specifically, it checks for a field \"replication\" that contains an object with the replication options. See the example below for the default setting and for a standard \"Network Topology with replication factor of 3\" setting.\r\n\r\n```javascript\r\n\r\n    //Standard setting (passed to cassie)\r\n    config {\r\n        hosts: ['127.0.0.1', '127.0.0.2', '127.0.0.3'],\r\n        keyspace: 'mykeyspace',\r\n        replication: {\r\n            strategy: 'SimpleStrategy', //Default is 'SimpleStrategy', NOTE: Use 'NetworkTopologyStrategy' for production\r\n            replication_factor: 1, //Default is 1 (only used with SimpleStrategy). Not used for 'NetworkTopologyStrategy'\r\n            strategy_options: { //Strategy options is only used for NetworkTopologyStrategy, not for SimpleStrategy\r\n                '0': 3\r\n                // '10':3,\r\n                // '20':3\r\n            }\r\n    }\r\n    \r\n    //Strategy options is only taken into account for NetworkTopologyStrategy - if not specified, then throws error if trying to sync. The key specified in strategy options is your database name (which varies based on what \"Snitch\" you set in your cassandra.yaml file. For a file property based snitch, you would define it to be your database name. The '0' here is specified if you use a RankInferringSnitch and your database is located at an internal IP of xxx.0.xxx.xxx (see Cassandra Documentation for more information).\r\n    \r\n\r\n```\r\n\r\nCommon Issues using Cassandra\r\n----------\r\n \r\nYou can't sort or use greater than or less than operators on a non-composite primary key column (see example below on what you can sort on). Partition keys can only be searched using equality or \"IN\". The way to get around this is to use composite primary keys with the appropriate columns. Because of this, you need to design your data models differently (full normalization is generally not a good idea, your data needs to be partially denormalized for good consistent performance - see Data modeling notes for more information).\r\n  \r\nAccording to some Datastax documentation, secondary indices are usually only good when you have fields that are common across many rows. A good example is when you have a list of people, each containing state and country information. You would put a secondary index on the state field and on the country field if you wanted to query \"What users are located in this state\" or \"What users are located in this country\". You can only use equality operators on secondary indices (see example below)\r\n  \r\nUnlike MySQL, PostgreSQL, or other Relational Databases, you can't do JOINs across tables in Cassandra. This also means that its not a good idea to fully normalize your data (see \"Data Modeling Notes\". \r\n  \r\nUnlike MongoDB (or recent versions of PostgreSQL with hstore/json data types), you can't put arbitrary JSON data into Cassandra (must define a schema - although you can always add columns later). Note that you can put maps and blobs/buffers into Cassandra, but its generally not a good idea to use Blobs over 10MB according to many data modeling best practices. Also note that you could store the json as a string and handle JSON stringifying during inserts and JSON parsing during retrieval. Cassie relaxes schema definitions significantly by auto syncing your tables and warning you when your schema may be missing columns that are defined in the database. However, do note that primary keys are defined at table CREATION time and cannot be altered.\r\n   \r\nUnlike MongoDB and Riak, Cassandra doesn't come with full text search built-in. You would need to use Apache Solr, Elastic Search, or any other full text search indexing engine to support full text search (Datastax Enterprise is built on top of Cassandra and has Apache Solr integration; you can also achieve something similar by writing an Elastic Search river that pulls data from Cassandra / is pushed data from your app or a Cassandra 2.1 Trigger). Note that with any full-text search indexing solution that is not directly tied to your primary data store, you can end up with consistency issues. The tradeoff is that by not directly tying your search indices in your database, you can scale each component separately (and deal with the consistency issue by manually pushing/pulling data into your search index). With Cassie plugins, it would be possible to add a pre/post save hook to add (push data) to your search index of choice and a model method (like Model.search) to query the search index instead of Cassandra.\r\n   \r\nCassandra is not a graph database like neo4j or OrientDB, but you can apparently integrate Titan with Cassandra for Graph / Geolocation type queries.\r\n\r\nCassandra does not come with Map Reduce capabilities built in, but you can integrate with Apache Spark / Apache Hadoop for advanced Map Reduce queries / operations (Datastax Enterprise apparently comes with integrations for Hadoop).\r\n\r\nSee Data Modeling Notes and Common Examples for how to model common use cases (One-to-many modeling, Many-to-many modeling, transactions, pagination, etc.) and how to use Cassandra effectively.\r\n\r\n```javascript\r\n\r\n    //Can't sort on name\r\n    var UserSchema = new Schema({user_id: Number, name: String}, {primary: ['user_id']});\r\n    var User = cassie.model('User', UserSchema);\r\n    User.find({user_id: [1000, 1001, 1002, 1003]}).sort({name: 1}).exec(callback);\r\n    \r\n    //Can't sort on name\r\n    var UserSchema = new Schema({user_id: Number, name: String}, {primary: ['user_id']});\r\n    UserSchema.index('name');\r\n    var User = cassie.model('User', UserSchema);\r\n    User.find({user_id: [1000, 1001, 1002, 1003]}).sort({name: 1}).exec(callback);\r\n\r\n    //Can sort on name (Composite primary key)\r\n    var UserSchema = new Schema({user_id: Number, name: String}, {primary: ['user_id', 'name']});\r\n    var User = cassie.model('User', UserSchema);\r\n    User.find({user_id: [2000, 2001, 2002, 2003]}).limit(10).sort({name: 1}).exec(callback);\r\n    \r\n    //Secondary index can only use '=' operator\r\n    var UserSchema = new Schema({user_id: Number, name: String}, {primary: ['user_id']});\r\n    UserSchema.index('name');\r\n    var User = cassie.model('User', UserSchema);\r\n    User.find({name: 'smith'}, callback); //Works\r\n    User.find({name: ['smith', 'bob']}, callback); //Doesn't work\r\n    User.find({name: {$gt: 'bob', $lt: 'smith'}}, callback) //Doesn't work\r\n\r\n\r\n```\r\n\r\nWhy Cassandra\r\n----------\r\n\r\nCassandra provides a truly distributed, fault tolerant design (kind of like an auto-sharded, auto-replicated, master-master database). Cassandra is designed so that if any one node goes down, you can create another node, attach it to the cluster, and retrieve the \"lost\" data without any downtime (based on your cluster settings). Cassandra provides linearly scalable reads and writes based on the number of nodes in a cluster (and is highly optimized for write throughput). In other words, when you need more reads/sec or writes/sec, you can simply add another node to the cluster. This means that your database can scale automatically similarly to how your API layer can (with good data modeling practices, some initialization scripts & virtual machine tweaks of course).\r\n \r\n If you follow good data modeling practices, (see \"Data Modeling Notes\"), you can do most queries that you would normally do in SQL databases or MongoDB using just CQL (some exceptions are full-text search, graph queries, map reduce jobs - see Elastic Search / Solr for search, Titan for graph queries, Apache Spark / Hadoop for map reduce jobs).\r\n \r\n In addition, Cassandra is built with multi-datacenter support (across Wide Area Networks (WAN)).\r\n \r\n Also see [this](http://planetcassandra.org/what-is-apache-cassandra/).\r\n \r\nData Modelling Notes\r\n----------\r\n\r\nDatastax has tutorials on data modeling:\r\n\r\n[Datastax Data Modeling](http://www.datastax.com/resources/data-modeling)\r\n\r\nIn particular, see this one for common examples from traditional SQL Data modeling (One-to-many, Many-to-many, transactions): [Link](https://www.youtube.com/watch?v=px6U2n74q3g)\r\n\r\nIts highly recommended that you view at least the above video and read these two tutorials on Cassandra Data Modeling before designing your models.\r\n\r\n[Cassandra Data Modeling Best Practices Part 1 - Ebay Tech Blog](http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1/#.U7YP_Y1dU_Q)\r\n[Cassandra Data Modeling Best Practices Part 2 - Ebay Tech Blog](http://www.ebaytechblog.com/2012/08/14/cassandra-data-modeling-best-practices-part-2/#.U7YQGI1dU_Q)\r\n\r\nThis is a powerpoint based on the above articles [Cassandra Data Modeling Best Practices](http://www.slideshare.net/jaykumarpatel/cassandra-data-modeling-best-practices).\r\n\r\nIn addition, take a look at some of Datastax's other tutorials:\r\n\r\n[Datastax Cassandra Tutorials](http://www.datastax.com/dev/tutorials)\r\n\r\nNot yet supported (on roadmap)\r\n----------\r\n\r\nCassie Side:\r\n* Hinting - node-cassandra-cql supports hinting (if you need to use it, use the node-cassandra-cql connection to make your query)\r\n* Collections - collection modifications - (UPDATE/REMOVE in single query with IN clause is supported, but Cassie doesn't do collection manipulation yet)\r\n* Proper collection updates - list & map do not update accurately using Cassie (must manually use CQL for updates) - see [this video](https://www.youtube.com/watch?v=qphhxujn5Es) from 10-16 minutes.\r\n* Queries loaded from external CQL files - [node-priam](https://github.com/godaddy/node-priam) supports this currently, it also supports Fluent syntax for manual cql creation, and some other options for retry handling. Since Cassie is an ODM, it will probably not have \"fluent syntax\" for manual cql creation, but it does support plugins and can offer similar functionality through the \"addQuery\" method on Schemas.\r\n* Counters are not supported by Cassie (alternative is to use Integers or use the node-cassandra-cql connection to manually run queries or use the addQuery method on schemas)\r\n* Select COUNT(*) is not currently supported by Cassie (use raw cql query)\r\n* Change type of defined columns - should be possible, but need a translation layer between Cassandra's Java Marshaller classes and Cassie types\r\n* Stream rows - node-cassandra-cql supports it (connection.eachRows), but it was failing in Cassie's tests, so its not included at the moment (stream is included though and performs a similar function)\r\n* Advanced table creation options - Not currently supported by cassie (alternative is to use ALTER TABLE in cqlsh or create table manually in cqlsh)\r\n* Paging - Generic Paging support is not quite ready yet (to use client side paging, see \"Data Modeling Notes\"). Also see driver issue below.\r\n\r\nPlugins / Other useful functionality (separate repos, build on top of cassie or as cassie-plugins):\r\n* Elastic Search Plugin (cassie-elastic-search-plugin) - for async pushing of Cassie models to elastic search index and querying said index (note can lead to consistency issues if push to elastic search fails in a post-save scenario)\r\n* Sessions (connect-cassie) - Create CassieStore to store user sessions\r\n* Easy Performance Testing - Expand timing, debugging and modeling to support quick testing of query performance on test clusters to simulate real client load\r\n\r\n* Testing Update with TTL\r\n* Migrating all tests to automated testing with Mocha / Istanbul (see readme-tests directory)\r\n\r\n* Not on roadmap: Connecting to multiple keyspaces (ie keyspace multi-tenancy with one app) - Can currently use a new connection and manually run CQL, but can't sync over multiple keyspaces because schemas and models are tied to a single cassie instance. Current way to deal with this is to use a separate server process (ie a different express/nodejs server process) and don't do multitenancy over multiple keyspaces in the same server process.\r\n\r\nDriver Side:\r\n* Paging - Cassie supports rudimentary client side paging where the token and a count is provided, but the node-cassandra-cql driver doesn't seem to have support for native paging yet (as of v0.5.0). It seems to be in node-cassandra-cql master on github, but not in released versions.\r\n* Input Streaming - not supported by node-cassandra-cql yet\r\n* SSL Connections - not supported by node-cassandra-cql yet\r\n* Auto determine other hosts - not supported by node-cassandra-cql yet\r\n* \"Smart connections\" - Only send CQL request to the hosts that contain the data (requires knowing about how the data is sharded, apparently Netflix uses something like this) - this might have to be based on your Schemas & how Cassandra is handling the sharding based on partition key. Naive Hypothesis: It might be possible by querying the system keyspace in Cassandra to determine which hosts contain the relevant shard keys periodically.\r\n* Possibly switch to officially supported native C/C++ driver when out of beta (would need to test performance, wrap C functions in javascript, and possibly do Javascript type to C type conversions / hinting in Cassie) - [https://github.com/datastax/cpp-driver](https://github.com/datastax/cpp-driver) and see Apache JIRA for project (note that this would mean making a node module like hiredis that compiles C/C++ code on multiple platforms)\r\n\r\nTesting & Development\r\n----------\r\nPre-reqs:\r\nNodejs installed and a Cassandra server running on localhost:9042\r\nClone the repository and run the following from command line:\r\n\r\n```\r\n\r\n    npm install && npm test\r\n\r\n```\r\n\r\nNote: 'npm test' creates a keyspace \"cassietest\" on your local Cassandra server then deletes it when done.\r\n\r\nGet code coverage reports by running 'npm run test-coverage' (coverage reports will go into /coverage directory - these reports are not exactly accurate because they don't take into account tests in the /readme-tests directory - see roadmap).\r\n\r\nSubmit pull requests for any bug fixes and add issues if you encounter them!\r\n\r\nMore information about Cassandra including Installation Guides, Production Setups, and Data Modeling Best Practices\r\n----------\r\n\r\nFor information on Cassandra, go to the [Apache Cassandra homepage](http://cassandra.apache.org/).\r\n\r\nFor information on CQL, see [Cassandra 2.0 CQL Reference](http://www.datastax.com/documentation/cql/3.1/cql/cql_intro_c.html)\r\n\r\nFor information on Cassandra's fault-tolerant, distributed architecture, see [the original Facebook whitepaper on Cassandra annotated with differences](http://www.datastax.com/documentation/articles/cassandra/cassandrathenandnow.html). Alternatively, also read Google's [BigTable architecture whitepaper](http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf) and [Amazon's Dynamo whitepaper](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) as Cassandra's design was influenced by both.\r\n\r\nFor helpful tips on data modeling in Cassandra (particularly if you come from a SQL background), see these links:\r\n* [Datastax Data Modeling](http://www.datastax.com/resources/data-modeling)\r\n* [Datastax Cassandra Tutorials](http://www.datastax.com/dev/tutorials)\r\n* [Cassandra Data Modeling Best Practices Part 1 - Ebay Tech Blog](http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1/#.U7YP_Y1dU_Q)\r\n* [Cassandra Data Modeling Best Practices Part 2 - Ebay Tech Blog](http://www.ebaytechblog.com/2012/08/14/cassandra-data-modeling-best-practices-part-2/#.U7YQGI1dU_Q)\r\n\r\nOther databases to look at if Cassandra doesn't fit your data needs: MySQL, PostgreSQL, MongoDB, Riak, neo4j, Oracle, Microsoft SQL Server.\r\n\r\nSome options to use if Cassandra doesn't support your query needs: Elastic Search / Solr for search indices, Titan for graph queries, Apache Spark / Apache Hadoop for map reduce operations, Apache Storm for general distributed data processing.\r\n\r\nLICENSE\r\n---------\r\n\r\nThe MIT License\r\n\r\nCopyright (c) 2014 Suyog Sonwalkar <flux159@gmail.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","google":"UA-47539617-6","note":"Don't delete this file! It's used internally to help with page regeneration."}